!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
APP_STATE_AND_EVENTS	app_state_and_events.h	2;"	d
Accessed	imgui_internal.h	/^    bool                    Accessed;                           \/\/ Set to true when any widget access the current window$/;"	m	struct:ImGuiWindow
Active	imgui_internal.h	/^    bool                    Active;                             \/\/ Set to true on Begin()$/;"	m	struct:ImGuiWindow
ActiveClickDeltaToCenter	imgui_internal.h	/^    ImVec2                  ActiveClickDeltaToCenter;$/;"	m	struct:ImGuiState
ActiveId	imgui_internal.h	/^    ImGuiID                 ActiveId;                           \/\/ Active widget$/;"	m	struct:ImGuiState
ActiveIdAllowOverlap	imgui_internal.h	/^    bool                    ActiveIdAllowOverlap;               \/\/ Set only by active widget$/;"	m	struct:ImGuiState
ActiveIdIsAlive	imgui_internal.h	/^    bool                    ActiveIdIsAlive;$/;"	m	struct:ImGuiState
ActiveIdIsJustActivated	imgui_internal.h	/^    bool                    ActiveIdIsJustActivated;            \/\/ Set at the time of activation for one frame$/;"	m	struct:ImGuiState
ActiveIdPreviousFrame	imgui_internal.h	/^    ImGuiID                 ActiveIdPreviousFrame;$/;"	m	struct:ImGuiState
ActiveIdWindow	imgui_internal.h	/^    ImGuiWindow*            ActiveIdWindow;$/;"	m	struct:ImGuiState
Add	imgui_internal.h	/^    void        Add(const ImRect& rhs)          { if (Min.x > rhs.Min.x) Min.x = rhs.Min.x; if (Min.y > rhs.Min.y) Min.y = rhs.Min.y; if (Max.x < rhs.Max.x) Max.x = rhs.Max.x; if (Max.y < rhs.Max.y) Max.y = rhs.Max.y; }$/;"	f	struct:ImRect
Add	imgui_internal.h	/^    void        Add(const ImVec2& rhs)          { if (Min.x > rhs.x)     Min.x = rhs.x;     if (Min.y > rhs.y) Min.y = rhs.y;         if (Max.x < rhs.x) Max.x = rhs.x;         if (Max.y < rhs.y) Max.y = rhs.y; }$/;"	f	struct:ImRect
AddBezierCurve	imgui_draw.cpp	/^void ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)$/;"	f	class:ImDrawList
AddCallback	imgui_draw.cpp	/^void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)$/;"	f	class:ImDrawList
AddCircle	imgui_draw.cpp	/^void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)$/;"	f	class:ImDrawList
AddCircleFilled	imgui_draw.cpp	/^void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList
AddConvexPolyFilled	imgui_draw.cpp	/^void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)$/;"	f	class:ImDrawList
AddDrawCmd	imgui_draw.cpp	/^void ImDrawList::AddDrawCmd()$/;"	f	class:ImDrawList
AddDrawListToRenderList	imgui.cpp	/^static void AddDrawListToRenderList(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list)$/;"	f	file:
AddFont	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)$/;"	f	class:ImFontAtlas
AddFontDefault	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)$/;"	f	class:ImFontAtlas
AddFontFromFileTTF	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryCompressedBase85TTF	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryCompressedTTF	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryTTF	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddImage	imgui_draw.cpp	/^void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv0, const ImVec2& uv1, ImU32 col)$/;"	f	class:ImDrawList
AddInputCharacter	imgui.cpp	/^void ImGuiIO::AddInputCharacter(ImWchar c)$/;"	f	class:ImGuiIO
AddInputCharactersUTF8	imgui.cpp	/^void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)$/;"	f	class:ImGuiIO
AddLine	imgui_draw.cpp	/^void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)$/;"	f	class:ImDrawList
AddPolyline	imgui_draw.cpp	/^void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)$/;"	f	class:ImDrawList
AddRect	imgui_draw.cpp	/^void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners, float thickness)$/;"	f	class:ImDrawList
AddRectFilled	imgui_draw.cpp	/^void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners)$/;"	f	class:ImDrawList
AddRectFilledMultiColor	imgui_draw.cpp	/^void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)$/;"	f	class:ImDrawList
AddText	imgui_draw.cpp	/^void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)$/;"	f	class:ImDrawList
AddText	imgui_draw.cpp	/^void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)$/;"	f	class:ImDrawList
AddTriangle	imgui_draw.cpp	/^void ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)$/;"	f	class:ImDrawList
AddTriangleFilled	imgui_draw.cpp	/^void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList
AddWindowSettings	imgui.cpp	/^static ImGuiIniData* AddWindowSettings(const char* name)$/;"	f	file:
AddWindowToRenderList	imgui.cpp	/^static void AddWindowToRenderList(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window)$/;"	f	file:
AddWindowToSortedBuffer	imgui.cpp	/^static void AddWindowToSortedBuffer(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window)$/;"	f	file:
AdvanceCursor	imgui_internal.h	/^    bool        AdvanceCursor;$/;"	m	struct:ImGuiGroupData
AlignFirstTextHeightToWidgets	imgui.cpp	/^void ImGui::AlignFirstTextHeightToWidgets()$/;"	f	class:ImGui
AllowKeyboardFocus	imgui_internal.h	/^    bool                    AllowKeyboardFocus;     \/\/ == AllowKeyboardFocusStack.back() [empty == true]$/;"	m	struct:ImGuiDrawContext
AllowKeyboardFocusStack	imgui_internal.h	/^    ImVector<bool>          AllowKeyboardFocusStack;$/;"	m	struct:ImGuiDrawContext
Alpha	imgui.h	/^    float       Alpha;                      \/\/ Global alpha applies to everything in ImGui$/;"	m	struct:ImGuiStyle
AntiAliasedLines	imgui.h	/^    bool        AntiAliasedLines;           \/\/ Enable anti-aliasing on lines\/borders. Disable if you are really tight on CPU\/GPU.$/;"	m	struct:ImGuiStyle
AntiAliasedShapes	imgui.h	/^    bool        AntiAliasedShapes;          \/\/ Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)$/;"	m	struct:ImGuiStyle
AppStateAndEvents	app_state_and_events.cpp	/^AppStateAndEvents::AppStateAndEvents(): MouseToCamera{false}, camera_pos{0, 0, 6}, camera_target{0, 0, 0}, outdoor{true} {$/;"	f	class:AppStateAndEvents
AppStateAndEvents	app_state_and_events.h	/^class AppStateAndEvents {$/;"	c
Ascent	imgui.h	/^    float                       Ascent, Descent;    \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont
AutoFitFramesX	imgui_internal.h	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow
AutoFitFramesY	imgui_internal.h	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow
AutoFitOnlyGrows	imgui_internal.h	/^    bool                    AutoFitOnlyGrows;$/;"	m	struct:ImGuiWindow
AutoPosLastDirection	imgui_internal.h	/^    int                     AutoPosLastDirection;$/;"	m	struct:ImGuiWindow
BEZIERCURVE_001	palace.h	23;"	d
BEZIERCURVE_002	palace.h	13;"	d
BEZIERCURVE_004	palace.h	5;"	d
BUFFER_OFFSET	func.h	27;"	d
BackupCurrentLineHeight	imgui_internal.h	/^    float       BackupCurrentLineHeight;$/;"	m	struct:ImGuiGroupData
BackupCurrentLineTextBaseOffset	imgui_internal.h	/^    float       BackupCurrentLineTextBaseOffset;$/;"	m	struct:ImGuiGroupData
BackupCursorMaxPos	imgui_internal.h	/^    ImVec2      BackupCursorMaxPos;$/;"	m	struct:ImGuiGroupData
BackupCursorPos	imgui_internal.h	/^    ImVec2      BackupCursorPos;$/;"	m	struct:ImGuiGroupData
BackupIndentX	imgui_internal.h	/^    float       BackupIndentX;$/;"	m	struct:ImGuiGroupData
BackupLogLinePosY	imgui_internal.h	/^    float       BackupLogLinePosY;$/;"	m	struct:ImGuiGroupData
Begin	imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_opened, ImGuiWindowFlags flags)$/;"	f	class:ImGui
Begin	imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_opened, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)$/;"	f	class:ImGui
Begin	imgui.h	/^    void Begin(int count, float height)        \/\/ items_height: generally pass GetTextLineHeightWithSpacing() or GetItemsLineHeightWithSpacing()$/;"	f	struct:ImGuiListClipper
BeginChild	imgui.cpp	/^bool ImGui::BeginChild(ImGuiID id, const ImVec2& size, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginChild	imgui.cpp	/^bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginChildFrame	imgui.cpp	/^bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginCount	imgui_internal.h	/^    int                     BeginCount;                         \/\/ Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin\/End pairs)$/;"	m	struct:ImGuiWindow
BeginGroup	imgui.cpp	/^void ImGui::BeginGroup()$/;"	f	class:ImGui
BeginMainMenuBar	imgui.cpp	/^bool ImGui::BeginMainMenuBar()$/;"	f	class:ImGui
BeginMenu	imgui.cpp	/^bool ImGui::BeginMenu(const char* label, bool enabled)$/;"	f	class:ImGui
BeginMenuBar	imgui.cpp	/^bool ImGui::BeginMenuBar()$/;"	f	class:ImGui
BeginPopup	imgui.cpp	/^bool ImGui::BeginPopup(const char* str_id)$/;"	f	class:ImGui
BeginPopupContextItem	imgui.cpp	/^bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)$/;"	f	class:ImGui
BeginPopupContextVoid	imgui.cpp	/^bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)$/;"	f	class:ImGui
BeginPopupContextWindow	imgui.cpp	/^bool ImGui::BeginPopupContextWindow(bool also_over_items, const char* str_id, int mouse_button)$/;"	f	class:ImGui
BeginPopupEx	imgui.cpp	/^static bool BeginPopupEx(const char* str_id, ImGuiWindowFlags extra_flags)$/;"	f	file:
BeginPopupModal	imgui.cpp	/^bool ImGui::BeginPopupModal(const char* name, bool* p_opened, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginTooltip	imgui.cpp	/^void ImGui::BeginTooltip()$/;"	f	class:ImGui
BorderSize	imgui_internal.h	/^    float                   BorderSize;$/;"	m	struct:ImGuiWindow
Buf	imgui.h	/^    ImVector<char>      Buf;$/;"	m	struct:ImGuiTextBuffer
Buf	imgui.h	/^    char*               Buf;            \/\/ Current text buffer                  \/\/ Read-write (pointed data only, can't replace the actual pointer)$/;"	m	struct:ImGuiTextEditCallbackData
Buf	imgui_demo.cpp	/^    ImGuiTextBuffer     Buf;$/;"	m	struct:ExampleAppLog	file:
BufDirty	imgui.h	/^    bool                BufDirty;       \/\/ Set if you modify Buf\/BufTextLen!!   \/\/ Write$/;"	m	struct:ImGuiTextEditCallbackData
BufSize	imgui.h	/^    int                 BufSize;        \/\/ Maximum text length in bytes         \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData
BufSizeA	imgui_internal.h	/^    int                 BufSizeA;                   \/\/ end-user buffer size$/;"	m	struct:ImGuiTextEditState
BufTextLen	imgui.h	/^    int                 BufTextLen;     \/\/ Current text length in bytes         \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData
Build	imgui.cpp	/^void ImGuiTextFilter::Build()$/;"	f	class:ImGuiTextFilter
Build	imgui_draw.cpp	/^bool    ImFontAtlas::Build()$/;"	f	class:ImFontAtlas
BuildLookupTable	imgui_draw.cpp	/^void ImFont::BuildLookupTable()$/;"	f	class:ImFont
Bullet	imgui.cpp	/^void ImGui::Bullet()$/;"	f	class:ImGui
BulletText	imgui.cpp	/^void ImGui::BulletText(const char* fmt, ...)$/;"	f	class:ImGui
BulletTextV	imgui.cpp	/^void ImGui::BulletTextV(const char* fmt, va_list args)$/;"	f	class:ImGui
Button	imgui.cpp	/^bool ImGui::Button(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui
ButtonBehavior	imgui.cpp	/^bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)$/;"	f	class:ImGui
ButtonEx	imgui.cpp	/^bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)$/;"	f	class:ImGui
ButtonRepeat	imgui_internal.h	/^    bool                    ButtonRepeat;           \/\/ == ButtonRepeatStack.back() [empty == false]$/;"	m	struct:ImGuiDrawContext
ButtonRepeatStack	imgui_internal.h	/^    ImVector<bool>          ButtonRepeatStack;$/;"	m	struct:ImGuiDrawContext
CUBE	palace.h	21;"	d
CUBE	untitled.h	10;"	d
CUBE_001	palace.h	20;"	d
CUBE_001	untitled.h	8;"	d
CUBE_002	palace.h	22;"	d
CUBE_002	untitled.h	7;"	d
CUBE_003	palace.h	19;"	d
CUBE_003	untitled.h	6;"	d
CUBE_004	palace.h	18;"	d
CUBE_004	untitled.h	5;"	d
CUBE_005	palace.h	17;"	d
CUBE_005	untitled.h	11;"	d
CUBE_006	palace.h	16;"	d
CUBE_007	palace.h	15;"	d
CUBE_008	palace.h	14;"	d
CUBE_009	palace.h	12;"	d
CUBE_010	palace.h	11;"	d
CUBE_011	palace.h	10;"	d
CUBE_012	palace.h	9;"	d
CUBE_013	palace.h	8;"	d
CUBE_014	palace.h	7;"	d
CUBE_015	palace.h	6;"	d
CalcExtraSpace	imgui.cpp	/^float ImGuiSimpleColumns::CalcExtraSpace(float avail_w)$/;"	f	class:ImGuiSimpleColumns
CalcFontSize	imgui_internal.h	/^    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }$/;"	f	struct:ImGuiWindow
CalcItemRectClosestPoint	imgui.cpp	/^ImVec2 ImGui::CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge, float outward)$/;"	f	class:ImGui
CalcItemSize	imgui.cpp	/^ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)$/;"	f	class:ImGui
CalcItemWidth	imgui.cpp	/^float ImGui::CalcItemWidth()$/;"	f	class:ImGui
CalcListClipping	imgui.cpp	/^void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)$/;"	f	class:ImGui
CalcTextSize	imgui.cpp	/^ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)$/;"	f	class:ImGui
CalcTextSizeA	imgui_draw.cpp	/^ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const$/;"	f	class:ImFont
CalcWordWrapPositionA	imgui_draw.cpp	/^const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const$/;"	f	class:ImFont
CalcWrapWidthForPos	imgui.cpp	/^float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)$/;"	f	class:ImGui
Capacity	imgui.h	/^    int                         Capacity;$/;"	m	class:ImVector
CaptureKeyboardFromApp	imgui.cpp	/^void ImGui::CaptureKeyboardFromApp(bool capture)$/;"	f	class:ImGui
CaptureKeyboardNextFrame	imgui_internal.h	/^    int                     CaptureKeyboardNextFrame;$/;"	m	struct:ImGuiState
CaptureMouseFromApp	imgui.cpp	/^void ImGui::CaptureMouseFromApp(bool capture)$/;"	f	class:ImGui
CaptureMouseNextFrame	imgui_internal.h	/^    int                     CaptureMouseNextFrame;              \/\/ explicit capture via CaptureInputs() sets those flags$/;"	m	struct:ImGuiState
ChannelsMerge	imgui_draw.cpp	/^void ImDrawList::ChannelsMerge()$/;"	f	class:ImDrawList
ChannelsSetCurrent	imgui_draw.cpp	/^void ImDrawList::ChannelsSetCurrent(int idx)$/;"	f	class:ImDrawList
ChannelsSplit	imgui_draw.cpp	/^void ImDrawList::ChannelsSplit(int channels_count)$/;"	f	class:ImDrawList
CheckStacksSize	imgui.cpp	/^static void CheckStacksSize(ImGuiWindow* window, bool write)$/;"	f	file:
Checkbox	imgui.cpp	/^bool ImGui::Checkbox(const char* label, bool* v)$/;"	f	class:ImGui
CheckboxFlags	imgui.cpp	/^bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)$/;"	f	class:ImGui
ChildWindowComparer	imgui.cpp	/^static int ChildWindowComparer(const void* lhs, const void* rhs)$/;"	f	file:
ChildWindowRounding	imgui.h	/^    float       ChildWindowRounding;        \/\/ Radius of child window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle
ChildWindows	imgui_internal.h	/^    ImVector<ImGuiWindow*>  ChildWindows;$/;"	m	struct:ImGuiDrawContext
Clear	imgui.cpp	/^void ImGuiStorage::Clear()$/;"	f	class:ImGuiStorage
Clear	imgui.h	/^    void                Clear() { InputBuf[0] = 0; Build(); }$/;"	f	struct:ImGuiTextFilter
Clear	imgui_demo.cpp	/^    void    Clear()     { Buf.clear(); LineOffsets.clear(); }$/;"	f	struct:ExampleAppLog
Clear	imgui_draw.cpp	/^void    ImFont::Clear()$/;"	f	class:ImFont
Clear	imgui_draw.cpp	/^void    ImFontAtlas::Clear()$/;"	f	class:ImFontAtlas
Clear	imgui_draw.cpp	/^void ImDrawList::Clear()$/;"	f	class:ImDrawList
ClearFonts	imgui_draw.cpp	/^void    ImFontAtlas::ClearFonts()$/;"	f	class:ImFontAtlas
ClearFreeMemory	imgui_draw.cpp	/^void ImDrawList::ClearFreeMemory()$/;"	f	class:ImDrawList
ClearInputCharacters	imgui.h	/^    IMGUI_API void ClearInputCharacters() { InputCharacters[0] = 0; }   \/\/ Helper to clear the text input buffer$/;"	f	struct:ImGuiIO
ClearInputData	imgui_draw.cpp	/^void    ImFontAtlas::ClearInputData()$/;"	f	class:ImFontAtlas
ClearLog	imgui_demo.cpp	/^    void    ClearLog()$/;"	f	struct:ExampleAppConsole
ClearSelection	imgui_internal.h	/^    void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }$/;"	f	struct:ImGuiTextEditState
ClearSetNextWindowData	imgui.cpp	/^static inline void ClearSetNextWindowData()$/;"	f	file:
ClearTexData	imgui_draw.cpp	/^void    ImFontAtlas::ClearTexData()$/;"	f	class:ImFontAtlas
Clip	imgui_internal.h	/^    void        Clip(const ImRect& clip)        { if (Min.x < clip.Min.x) Min.x = clip.Min.x; if (Min.y < clip.Min.y) Min.y = clip.Min.y; if (Max.x > clip.Max.x) Max.x = clip.Max.x; if (Max.y > clip.Max.y) Max.y = clip.Max.y; }$/;"	f	struct:ImRect
ClipRect	imgui.h	/^    ImVec4          ClipRect;               \/\/ Clipping rectangle (x1, y1, x2, y2)$/;"	m	struct:ImDrawCmd
ClipRect	imgui_internal.h	/^    ImRect                  ClipRect;                           \/\/ = DrawList->clip_rect_stack.back(). Scissoring \/ clipping rectangle. x1, y1, x2, y2.$/;"	m	struct:ImGuiWindow
ClippedWindowRect	imgui_internal.h	/^    ImRect                  ClippedWindowRect;                  \/\/ = ClipRect just after setup in Begin()$/;"	m	struct:ImGuiWindow
CloseCurrentPopup	imgui.cpp	/^void ImGui::CloseCurrentPopup()$/;"	f	class:ImGui
CloseInactivePopups	imgui.cpp	/^static void CloseInactivePopups()$/;"	f	file:
ClosePopup	imgui.cpp	/^static void ClosePopup(ImGuiID id)$/;"	f	file:
ClosePopupToLevel	imgui.cpp	/^static void ClosePopupToLevel(int remaining)$/;"	f	file:
CloseWindowButton	imgui.cpp	/^static bool CloseWindowButton(bool* p_opened)$/;"	f	file:
CmdBuffer	imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;          \/\/ Commands. Typically 1 command = 1 gpu draw call.$/;"	m	struct:ImDrawList
CmdBuffer	imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;$/;"	m	struct:ImDrawChannel
CmdLists	imgui.h	/^    ImDrawList**    CmdLists;$/;"	m	struct:ImDrawData
CmdListsCount	imgui.h	/^    int             CmdListsCount;$/;"	m	struct:ImDrawData
Codepoint	imgui.h	/^        ImWchar                 Codepoint;$/;"	m	struct:ImFont::Glyph
Col	imgui_internal.h	/^    ImGuiCol    Col;$/;"	m	struct:ImGuiColMod
Collapsed	imgui_internal.h	/^    bool                    Collapsed;                          \/\/ Set when collapsing window to become only title-bar$/;"	m	struct:ImGuiWindow
Collapsed	imgui_internal.h	/^    bool        Collapsed;$/;"	m	struct:ImGuiIniData
CollapsingHeader	imgui.cpp	/^bool ImGui::CollapsingHeader(const char* label, const char* str_id, bool display_frame, bool default_open)$/;"	f	class:ImGui
ColorButton	imgui.cpp	/^bool ImGui::ColorButton(const ImVec4& col, bool small_height, bool outline_border)$/;"	f	class:ImGui
ColorConvertFloat4ToU32	imgui.cpp	/^ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)$/;"	f	class:ImGui
ColorConvertHSVtoRGB	imgui.cpp	/^void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)$/;"	f	class:ImGui
ColorConvertRGBtoHSV	imgui.cpp	/^void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)$/;"	f	class:ImGui
ColorConvertU32ToFloat4	imgui.cpp	/^ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)$/;"	f	class:ImGui
ColorEdit3	imgui.cpp	/^bool ImGui::ColorEdit3(const char* label, float col[3])$/;"	f	class:ImGui
ColorEdit4	imgui.cpp	/^bool ImGui::ColorEdit4(const char* label, float col[4], bool alpha)$/;"	f	class:ImGui
ColorEditMode	imgui.cpp	/^void ImGui::ColorEditMode(ImGuiColorEditMode mode)$/;"	f	class:ImGui
ColorEditMode	imgui_internal.h	/^    ImGuiColorEditMode      ColorEditMode;$/;"	m	struct:ImGuiDrawContext
ColorEditModeStorage	imgui_internal.h	/^    ImGuiStorage            ColorEditModeStorage;               \/\/ Store user selection of color edit mode$/;"	m	struct:ImGuiState
ColorModifiers	imgui_internal.h	/^    ImVector<ImGuiColMod>   ColorModifiers;                     \/\/ Stack for PushStyleColor()\/PopStyleColor()$/;"	m	struct:ImGuiState
Colors	imgui.h	/^    ImVec4      Colors[ImGuiCol_COUNT];$/;"	m	struct:ImGuiStyle
Columns	imgui.cpp	/^void ImGui::Columns(int columns_count, const char* id, bool border)$/;"	f	class:ImGui
ColumnsCellMaxY	imgui_internal.h	/^    float                   ColumnsCellMaxY;$/;"	m	struct:ImGuiDrawContext
ColumnsCellMinY	imgui_internal.h	/^    float                   ColumnsCellMinY;$/;"	m	struct:ImGuiDrawContext
ColumnsCount	imgui_internal.h	/^    int                     ColumnsCount;$/;"	m	struct:ImGuiDrawContext
ColumnsCurrent	imgui_internal.h	/^    int                     ColumnsCurrent;$/;"	m	struct:ImGuiDrawContext
ColumnsData	imgui_internal.h	/^    ImVector<ImGuiColumnData> ColumnsData;$/;"	m	struct:ImGuiDrawContext
ColumnsMaxX	imgui_internal.h	/^    float                   ColumnsMaxX;$/;"	m	struct:ImGuiDrawContext
ColumnsMinSpacing	imgui.h	/^    float       ColumnsMinSpacing;          \/\/ Minimum horizontal spacing between two columns$/;"	m	struct:ImGuiStyle
ColumnsMinX	imgui_internal.h	/^    float                   ColumnsMinX;$/;"	m	struct:ImGuiDrawContext
ColumnsOffsetX	imgui_internal.h	/^    float                   ColumnsOffsetX;         \/\/ Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.$/;"	m	struct:ImGuiDrawContext
ColumnsSetID	imgui_internal.h	/^    ImGuiID                 ColumnsSetID;$/;"	m	struct:ImGuiDrawContext
ColumnsShowBorders	imgui_internal.h	/^    bool                    ColumnsShowBorders;$/;"	m	struct:ImGuiDrawContext
ColumnsStartPosY	imgui_internal.h	/^    float                   ColumnsStartPosY;$/;"	m	struct:ImGuiDrawContext
Combo	imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui
Combo	imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)$/;"	f	class:ImGui
Combo	imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char** items, int items_count, int height_in_items)$/;"	f	class:ImGui
Commands	imgui_demo.cpp	/^    ImVector<const char*> Commands;$/;"	m	struct:ExampleAppConsole	file:
ConfigData	imgui.h	/^    ImFontConfig*               ConfigData;         \/\/                 \/\/ Pointer within ImFontAtlas->ConfigData$/;"	m	struct:ImFont
ConfigData	imgui.h	/^    ImVector<ImFontConfig>      ConfigData;         \/\/ Internal data$/;"	m	struct:ImFontAtlas
ConfigDataCount	imgui.h	/^    int                         ConfigDataCount;    \/\/$/;"	m	struct:ImFont
ContainerAtlas	imgui.h	/^    ImFontAtlas*                ContainerAtlas;     \/\/ What we has been loaded into$/;"	m	struct:ImFont
Contains	imgui_internal.h	/^    bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }$/;"	f	struct:ImRect
Contains	imgui_internal.h	/^    bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }$/;"	f	struct:ImRect
Count	imgui_internal.h	/^    int         Count;$/;"	m	struct:ImGuiSimpleColumns
CountGrep	imgui.h	/^    int                 CountGrep;$/;"	m	struct:ImGuiTextFilter
CreateNewWindow	imgui.cpp	/^static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)$/;"	f	file:
CurLenA	imgui_internal.h	/^    int                 CurLenA, CurLenW;           \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState
CurLenW	imgui_internal.h	/^    int                 CurLenA, CurLenW;           \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState
CurrentLineHeight	imgui_internal.h	/^    float                   CurrentLineHeight;$/;"	m	struct:ImGuiDrawContext
CurrentLineTextBaseOffset	imgui_internal.h	/^    float                   CurrentLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext
CurrentPopupStack	imgui_internal.h	/^    ImVector<ImGuiPopupRef> CurrentPopupStack;                  \/\/ Which level of BeginPopup() we are in (reset every frame)$/;"	m	struct:ImGuiState
CurrentWindow	imgui_internal.h	/^    ImGuiWindow*            CurrentWindow;                      \/\/ Being drawn into$/;"	m	struct:ImGuiState
CurrentWindowStack	imgui_internal.h	/^    ImVector<ImGuiWindow*>  CurrentWindowStack;$/;"	m	struct:ImGuiState
CursorAnim	imgui_internal.h	/^    float               CursorAnim;$/;"	m	struct:ImGuiTextEditState
CursorAnimReset	imgui_internal.h	/^    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   \/\/ After a user-input the cursor stays on for a while without blinking$/;"	f	struct:ImGuiTextEditState
CursorClamp	imgui_internal.h	/^    void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }$/;"	f	struct:ImGuiTextEditState
CursorFollow	imgui_internal.h	/^    bool                CursorFollow;$/;"	m	struct:ImGuiTextEditState
CursorMaxPos	imgui_internal.h	/^    ImVec2                  CursorMaxPos;           \/\/ Implicitly calculate the size of our contents, always extending. Saved into window->SizeContents at the end of the frame$/;"	m	struct:ImGuiDrawContext
CursorPos	imgui.h	/^    int                 CursorPos;      \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData
CursorPos	imgui_internal.h	/^    ImVec2                  CursorPos;$/;"	m	struct:ImGuiDrawContext
CursorPosPrevLine	imgui_internal.h	/^    ImVec2                  CursorPosPrevLine;$/;"	m	struct:ImGuiDrawContext
CursorStartPos	imgui_internal.h	/^    ImVec2                  CursorStartPos;$/;"	m	struct:ImGuiDrawContext
CurveTessellationTol	imgui.h	/^    float       CurveTessellationTol;       \/\/ Tessellation tolerance. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.$/;"	m	struct:ImGuiStyle
DC	imgui_internal.h	/^    ImGuiDrawContext        DC;                                 \/\/ Temporary per-window data, reset at the beginning of the frame$/;"	m	struct:ImGuiWindow
Data	imgui.h	/^    ImVector<Pair>      Data;$/;"	m	struct:ImGuiStorage
Data	imgui.h	/^    T*                          Data;$/;"	m	class:ImVector
DataTypeApplyOp	imgui.cpp	/^static void DataTypeApplyOp(ImGuiDataType data_type, int op, void* value1, const void* value2)\/\/ Store into value1$/;"	f	file:
DataTypeApplyOpFromText	imgui.cpp	/^static bool DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format)$/;"	f	file:
DataTypeFormatString	imgui.cpp	/^static inline void DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size)$/;"	f	file:
DataTypeFormatString	imgui.cpp	/^static inline void DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size)$/;"	f	file:
DeIndexAllBuffers	imgui_draw.cpp	/^void ImDrawData::DeIndexAllBuffers()$/;"	f	class:ImDrawData
DeclColumns	imgui.cpp	/^float ImGuiSimpleColumns::DeclColumns(float w0, float w1, float w2) \/\/ not using va_arg because they promote float to double$/;"	f	class:ImGuiSimpleColumns
Decode85	imgui_draw.cpp	/^static void         Decode85(const unsigned char* src, unsigned char* dst)$/;"	f	file:
Decode85Byte	imgui_draw.cpp	/^static unsigned int Decode85Byte(char c)                                    { return c >= '\\\\' ? c-36 : c-35; }$/;"	f	file:
DeleteChars	imgui.cpp	/^void ImGuiTextEditCallbackData::DeleteChars(int pos, int bytes_count)$/;"	f	class:ImGuiTextEditCallbackData
DeltaTime	imgui.h	/^    float         DeltaTime;                \/\/ = 1.0f\/60.0f         \/\/ Time elapsed since last frame, in seconds.$/;"	m	struct:ImGuiIO
Descent	imgui.h	/^    float                       Ascent, Descent;    \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont
DisplayEnd	imgui.h	/^    int     ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper
DisplayFramebufferScale	imgui.h	/^    ImVec2        DisplayFramebufferScale;  \/\/ = (1.0f,1.0f)        \/\/ For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.$/;"	m	struct:ImGuiIO
DisplayOffset	imgui.h	/^    ImVec2                      DisplayOffset;      \/\/ = (0.0f,1.0f)   \/\/ Offset font rendering by xx pixels$/;"	m	struct:ImFont
DisplaySafeAreaPadding	imgui.h	/^    ImVec2      DisplaySafeAreaPadding;     \/\/ If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups\/tooltips as well regular windows.$/;"	m	struct:ImGuiStyle
DisplaySize	imgui.h	/^    ImVec2        DisplaySize;              \/\/ <unset>              \/\/ Display size, in pixels. For clamping windows positions.$/;"	m	struct:ImGuiIO
DisplayStart	imgui.h	/^    int     ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper
DisplayVisibleMax	imgui.h	/^    ImVec2        DisplayVisibleMax;        \/\/ <unset> (0.0f,0.0f)  \/\/ If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize$/;"	m	struct:ImGuiIO
DisplayVisibleMin	imgui.h	/^    ImVec2        DisplayVisibleMin;        \/\/ <unset> (0.0f,0.0f)  \/\/ If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin\/Max to the visible area.$/;"	m	struct:ImGuiIO
DisplayWindowPadding	imgui.h	/^    ImVec2      DisplayWindowPadding;       \/\/ Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.$/;"	m	struct:ImGuiStyle
DoubleClickSelectsWord	imgui.h	/^    bool          DoubleClickSelectsWord;   \/\/ = defined(__APPLE__) \/\/ OS X style: Double click selects by word instead of selecting whole text$/;"	m	struct:ImGuiIO
DragBehavior	imgui.cpp	/^bool ImGui::DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)$/;"	f	class:ImGui
DragCurrentValue	imgui_internal.h	/^    float                   DragCurrentValue;                   \/\/ Currently dragged value, always float, not rounded by end-user precision settings$/;"	m	struct:ImGuiState
DragFloat	imgui.cpp	/^bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
DragFloat2	imgui.cpp	/^bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
DragFloat3	imgui.cpp	/^bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
DragFloat4	imgui.cpp	/^bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
DragFloatN	imgui.cpp	/^bool ImGui::DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
DragFloatRange2	imgui.cpp	/^bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)$/;"	f	class:ImGui
DragInt	imgui.cpp	/^bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
DragInt2	imgui.cpp	/^bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
DragInt3	imgui.cpp	/^bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
DragInt4	imgui.cpp	/^bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
DragIntN	imgui.cpp	/^bool ImGui::DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
DragIntRange2	imgui.cpp	/^bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)$/;"	f	class:ImGui
DragLastMouseDelta	imgui_internal.h	/^    ImVec2                  DragLastMouseDelta;$/;"	m	struct:ImGuiState
DragSpeedDefaultRatio	imgui_internal.h	/^    float                   DragSpeedDefaultRatio;              \/\/ If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio$/;"	m	struct:ImGuiState
DragSpeedScaleFast	imgui_internal.h	/^    float                   DragSpeedScaleFast;$/;"	m	struct:ImGuiState
DragSpeedScaleSlow	imgui_internal.h	/^    float                   DragSpeedScaleSlow;$/;"	m	struct:ImGuiState
Draw	imgui.cpp	/^bool ImGuiTextFilter::Draw(const char* label, float width)$/;"	f	class:ImGuiTextFilter
Draw	imgui_demo.cpp	/^    void    Draw(const char* title, bool* opened)$/;"	f	struct:ExampleAppConsole
Draw	imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_opened = NULL)$/;"	f	struct:ExampleAppLog
DrawAllMeshes	func.h	/^void DrawAllMeshes()$/;"	f
DrawBaseBallField	render2d.cpp	/^static void DrawBaseBallField(AppStateAndEvents &ae, float dT) {$/;"	f	file:
DrawList	imgui_internal.h	/^    ImDrawList*             DrawList;$/;"	m	struct:ImGuiWindow
DrawMesh	func.h	/^void DrawMesh(unsigned int index, int apply_transformations) {$/;"	f
DrawScene	render2d.cpp	/^void DrawScene(AppStateAndEvents &ae, float dT) {$/;"	f
DrawScene	render3d.cpp	/^void DrawScene(AppStateAndEvents &ae, float dT) {$/;"	f
DstFont	imgui.h	/^    ImFont*         DstFont;$/;"	m	struct:ImFontConfig
Dummy	imgui.cpp	/^void ImGui::Dummy(const ImVec2& size)$/;"	f	class:ImGui
EVENT_H	event.h	2;"	d
ElemCount	imgui.h	/^    unsigned int    ElemCount;              \/\/ Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].$/;"	m	struct:ImDrawCmd
Encode85Byte	extra_fonts/binary_to_compressed_c.cpp	/^char Encode85Byte(unsigned int x) $/;"	f
End	imgui.cpp	/^void ImGui::End()$/;"	f	class:ImGui
End	imgui.h	/^    void End()$/;"	f	struct:ImGuiListClipper
EndChild	imgui.cpp	/^void ImGui::EndChild()$/;"	f	class:ImGui
EndChildFrame	imgui.cpp	/^void ImGui::EndChildFrame()$/;"	f	class:ImGui
EndFrame	imgui.cpp	/^void ImGui::EndFrame()$/;"	f	class:ImGui
EndGroup	imgui.cpp	/^void ImGui::EndGroup()$/;"	f	class:ImGui
EndMainMenuBar	imgui.cpp	/^void ImGui::EndMainMenuBar()$/;"	f	class:ImGui
EndMenu	imgui.cpp	/^void ImGui::EndMenu()$/;"	f	class:ImGui
EndMenuBar	imgui.cpp	/^void ImGui::EndMenuBar()$/;"	f	class:ImGui
EndPopup	imgui.cpp	/^void ImGui::EndPopup()$/;"	f	class:ImGui
EndTooltip	imgui.cpp	/^void ImGui::EndTooltip()$/;"	f	class:ImGui
EventChar	imgui.h	/^    ImWchar             EventChar;      \/\/ Character input                      \/\/ Read-write (replace character or set to zero)$/;"	m	struct:ImGuiTextEditCallbackData
EventFlag	imgui.h	/^    ImGuiInputTextFlags EventFlag;      \/\/ One of ImGuiInputTextFlags_Callback* \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData
EventKey	imgui.h	/^    ImGuiKey            EventKey;       \/\/ Key pressed (Up\/Down\/TAB)            \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData
ExampleAppConsole	imgui_demo.cpp	/^    ExampleAppConsole()$/;"	f	struct:ExampleAppConsole
ExampleAppConsole	imgui_demo.cpp	/^struct ExampleAppConsole$/;"	s	file:
ExampleAppLog	imgui_demo.cpp	/^struct ExampleAppLog$/;"	s	file:
ExecCommand	imgui_demo.cpp	/^    void    ExecCommand(const char* command_line)$/;"	f	struct:ExampleAppConsole
Expand	imgui_internal.h	/^    void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }$/;"	f	struct:ImRect
Expand	imgui_internal.h	/^    void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }$/;"	f	struct:ImRect
FallbackChar	imgui.h	/^    ImWchar                     FallbackChar;       \/\/ = '?'           \/\/ Replacement glyph if one isn't found. Only set via SetFallbackChar()$/;"	m	struct:ImFont
FallbackGlyph	imgui.h	/^    const Glyph*                FallbackGlyph;      \/\/ == FindGlyph(FontFallbackChar)$/;"	m	struct:ImFont
FallbackXAdvance	imgui.h	/^    float                       FallbackXAdvance;   \/\/$/;"	m	struct:ImFont
Filter	imgui_demo.cpp	/^    ImGuiTextFilter     Filter;$/;"	m	struct:ExampleAppLog	file:
Filters	imgui.h	/^    ImVector<TextRange> Filters;$/;"	m	struct:ImGuiTextFilter
FindBestPopupWindowPos	imgui.cpp	/^static ImVec2 FindBestPopupWindowPos(const ImVec2& base_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)$/;"	f	file:
FindGlyph	imgui_draw.cpp	/^const ImFont::Glyph* ImFont::FindGlyph(unsigned short c) const$/;"	f	class:ImFont
FindHoveredWindow	imgui.cpp	/^static ImGuiWindow* FindHoveredWindow(ImVec2 pos, bool excluding_childs)$/;"	f	file:
FindRenderedTextEnd	imgui.cpp	/^const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)$/;"	f	class:ImGui
FindWindowByName	imgui.cpp	/^ImGuiWindow* ImGui::FindWindowByName(const char* name)$/;"	f	class:ImGui
FindWindowSettings	imgui.cpp	/^static ImGuiIniData* FindWindowSettings(const char* name)$/;"	f	file:
Flags	imgui.h	/^    ImGuiInputTextFlags Flags;          \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData
Flags	imgui_internal.h	/^    ImGuiWindowFlags        Flags;$/;"	m	struct:ImGuiWindow
FocusIdxAllCounter	imgui_internal.h	/^    int                     FocusIdxAllCounter;                 \/\/ Start at -1 and increase as assigned via FocusItemRegister()$/;"	m	struct:ImGuiWindow
FocusIdxAllRequestCurrent	imgui_internal.h	/^    int                     FocusIdxAllRequestCurrent;          \/\/ Item being requested for focus$/;"	m	struct:ImGuiWindow
FocusIdxAllRequestNext	imgui_internal.h	/^    int                     FocusIdxAllRequestNext;             \/\/ Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)$/;"	m	struct:ImGuiWindow
FocusIdxTabCounter	imgui_internal.h	/^    int                     FocusIdxTabCounter;                 \/\/ (same, but only count widgets which you can Tab through)$/;"	m	struct:ImGuiWindow
FocusIdxTabRequestCurrent	imgui_internal.h	/^    int                     FocusIdxTabRequestCurrent;          \/\/ Tab-able item being requested for focus$/;"	m	struct:ImGuiWindow
FocusIdxTabRequestNext	imgui_internal.h	/^    int                     FocusIdxTabRequestNext;             \/\/ "$/;"	m	struct:ImGuiWindow
FocusWindow	imgui.cpp	/^void ImGui::FocusWindow(ImGuiWindow* window)$/;"	f	class:ImGui
FocusableItemRegister	imgui.cpp	/^bool ImGui::FocusableItemRegister(ImGuiWindow* window, bool is_active, bool tab_stop)$/;"	f	class:ImGui
FocusableItemUnregister	imgui.cpp	/^void ImGui::FocusableItemUnregister(ImGuiWindow* window)$/;"	f	class:ImGui
FocusedWindow	imgui_internal.h	/^    ImGuiWindow*            FocusedWindow;                      \/\/ Will catch keyboard inputs$/;"	m	struct:ImGuiState
Font	imgui_internal.h	/^    ImFont*                 Font;                               \/\/ (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()$/;"	m	struct:ImGuiState
FontAllowUserScaling	imgui.h	/^    bool          FontAllowUserScaling;     \/\/ = false              \/\/ Allow user scaling text of individual window with CTRL+Wheel.$/;"	m	struct:ImGuiIO
FontBaseSize	imgui_internal.h	/^    float                   FontBaseSize;                       \/\/ (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Size of characters.$/;"	m	struct:ImGuiState
FontData	imgui.h	/^    void*           FontData;                   \/\/          \/\/ TTF data$/;"	m	struct:ImFontConfig
FontDataOwnedByAtlas	imgui.h	/^    bool            FontDataOwnedByAtlas;       \/\/ true     \/\/ TTF data ownership taken by the container ImFontAtlas (will delete memory itself). Set to true$/;"	m	struct:ImFontConfig
FontDataSize	imgui.h	/^    int             FontDataSize;               \/\/          \/\/ TTF data size$/;"	m	struct:ImFontConfig
FontGlobalScale	imgui.h	/^    float         FontGlobalScale;          \/\/ = 1.0f               \/\/ Global scale all fonts$/;"	m	struct:ImGuiIO
FontNo	imgui.h	/^    int             FontNo;                     \/\/ 0        \/\/ Index of font within TTF file$/;"	m	struct:ImFontConfig
FontSize	imgui.h	/^    float                       FontSize;           \/\/ <user set>      \/\/ Height of characters, set during loading (don't change after loading)$/;"	m	struct:ImFont
FontSize	imgui_internal.h	/^    float                   FontSize;                           \/\/ (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize()$/;"	m	struct:ImGuiState
FontStack	imgui_internal.h	/^    ImVector<ImFont*>       FontStack;                          \/\/ Stack for PushFont()\/PopFont()$/;"	m	struct:ImGuiState
FontTexUvWhitePixel	imgui_internal.h	/^    ImVec2                  FontTexUvWhitePixel;                \/\/ (Shortcut) == Font->TexUvWhitePixel$/;"	m	struct:ImGuiState
FontWindowScale	imgui_internal.h	/^    float                   FontWindowScale;                    \/\/ Scale multiplier per-window$/;"	m	struct:ImGuiWindow
Fonts	imgui.h	/^    ImFontAtlas*  Fonts;                    \/\/ <auto>               \/\/ Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.$/;"	m	struct:ImGuiIO
Fonts	imgui.h	/^    ImVector<ImFont*>           Fonts;              \/\/ Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()\/PopFont() to change the current font.$/;"	m	struct:ImFontAtlas
FrameCount	imgui_internal.h	/^    int                     FrameCount;$/;"	m	struct:ImGuiState
FrameCountEnded	imgui_internal.h	/^    int                     FrameCountEnded;$/;"	m	struct:ImGuiState
FrameCountRendered	imgui_internal.h	/^    int                     FrameCountRendered;$/;"	m	struct:ImGuiState
FramePadding	imgui.h	/^    ImVec2      FramePadding;               \/\/ Padding within a framed rectangle (used by most widgets)$/;"	m	struct:ImGuiStyle
FrameRounding	imgui.h	/^    float       FrameRounding;              \/\/ Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).$/;"	m	struct:ImGuiStyle
Framerate	imgui.h	/^    float       Framerate;                  \/\/ Framerate estimation, in frame per second. Rolling average estimation based on IO.DeltaTime over 120 frames$/;"	m	struct:ImGuiIO
FramerateSecPerFrame	imgui_internal.h	/^    float                   FramerateSecPerFrame[120];          \/\/ calculate estimate of framerate for user$/;"	m	struct:ImGuiState
FramerateSecPerFrameAccum	imgui_internal.h	/^    float                   FramerateSecPerFrameAccum;$/;"	m	struct:ImGuiState
FramerateSecPerFrameIdx	imgui_internal.h	/^    int                     FramerateSecPerFrameIdx;$/;"	m	struct:ImGuiState
GImDefaultFontAtlas	imgui.cpp	/^static ImFontAtlas      GImDefaultFontAtlas;$/;"	v	file:
GImDefaultState	imgui.cpp	/^static ImGuiState       GImDefaultState;$/;"	v	file:
GImGui	imgui.cpp	/^ImGuiState*             GImGui = &GImDefaultState;$/;"	v
GL_GLEXT_PROTOTYPES	sdl_main.cpp	1;"	d	file:
GetBL	imgui_internal.h	/^    ImVec2      GetBL() const                   { return ImVec2(Min.x, Max.y); }  \/\/ Bottom-left$/;"	f	struct:ImRect
GetBR	imgui_internal.h	/^    ImVec2      GetBR() const                   { return Max; }                   \/\/ Bottom-right$/;"	f	struct:ImRect
GetCenter	imgui_internal.h	/^    ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }$/;"	f	struct:ImRect
GetCharAdvance	imgui.h	/^    float                       GetCharAdvance(unsigned short c) const  { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }$/;"	f	struct:ImFont
GetClipboardText	imgui.cpp	/^const char* ImGui::GetClipboardText()$/;"	f	class:ImGui
GetClipboardTextFn	imgui.h	/^    const char* (*GetClipboardTextFn)();$/;"	m	struct:ImGuiIO
GetClipboardTextFn_DefaultImpl	imgui.cpp	/^static const char* GetClipboardTextFn_DefaultImpl()$/;"	f	file:
GetClosestPoint	imgui_internal.h	/^    ImVec2      GetClosestPoint(ImVec2 p, bool on_edge) const$/;"	f	struct:ImRect
GetColorU32	imgui_internal.h	/^    inline IMGUI_API ImU32  GetColorU32(ImGuiCol idx, float alpha_mul)  { ImVec4 c = GImGui->Style.Colors[idx]; c.w *= GImGui->Style.Alpha * alpha_mul; return ImGui::ColorConvertFloat4ToU32(c); }$/;"	f	namespace:ImGui
GetColorU32	imgui_internal.h	/^    inline IMGUI_API ImU32  GetColorU32(const ImVec4& col)              { ImVec4 c = col; c.w *= GImGui->Style.Alpha; return ImGui::ColorConvertFloat4ToU32(c); }$/;"	f	namespace:ImGui
GetColumnIndex	imgui.cpp	/^int ImGui::GetColumnIndex()$/;"	f	class:ImGui
GetColumnOffset	imgui.cpp	/^float ImGui::GetColumnOffset(int column_index)$/;"	f	class:ImGui
GetColumnWidth	imgui.cpp	/^float ImGui::GetColumnWidth(int column_index)$/;"	f	class:ImGui
GetColumnsCount	imgui.cpp	/^int ImGui::GetColumnsCount()$/;"	f	class:ImGui
GetContentRegionAvail	imgui.cpp	/^ImVec2 ImGui::GetContentRegionAvail()$/;"	f	class:ImGui
GetContentRegionAvailWidth	imgui.cpp	/^float ImGui::GetContentRegionAvailWidth()$/;"	f	class:ImGui
GetContentRegionMax	imgui.cpp	/^ImVec2 ImGui::GetContentRegionMax()$/;"	f	class:ImGui
GetCurrentClipRect	imgui_draw.cpp	147;"	d	file:
GetCurrentClipRect	imgui_draw.cpp	214;"	d	file:
GetCurrentTextureId	imgui_draw.cpp	148;"	d	file:
GetCurrentTextureId	imgui_draw.cpp	215;"	d	file:
GetCurrentWindow	imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiState& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }$/;"	f	namespace:ImGui
GetCurrentWindowRead	imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiState& g = *GImGui; return g.CurrentWindow; }$/;"	f	namespace:ImGui
GetCursorPos	imgui.cpp	/^ImVec2 ImGui::GetCursorPos()$/;"	f	class:ImGui
GetCursorPosX	imgui.cpp	/^float ImGui::GetCursorPosX()$/;"	f	class:ImGui
GetCursorPosY	imgui.cpp	/^float ImGui::GetCursorPosY()$/;"	f	class:ImGui
GetCursorScreenPos	imgui.cpp	/^ImVec2 ImGui::GetCursorScreenPos()$/;"	f	class:ImGui
GetCursorStartPos	imgui.cpp	/^ImVec2 ImGui::GetCursorStartPos()$/;"	f	class:ImGui
GetDefaultCompressedFontDataTTFBase85	imgui_draw.cpp	/^static const char* GetDefaultCompressedFontDataTTFBase85()$/;"	f	file:
GetDraggedColumnOffset	imgui.cpp	/^static float GetDraggedColumnOffset(int column_index)$/;"	f	file:
GetDrawData	imgui.cpp	/^ImDrawData* ImGui::GetDrawData()$/;"	f	class:ImGui
GetFloat	imgui.cpp	/^float ImGuiStorage::GetFloat(ImU32 key, float default_val) const$/;"	f	class:ImGuiStorage
GetFloatRef	imgui.cpp	/^float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)$/;"	f	class:ImGuiStorage
GetFont	imgui.cpp	/^ImFont* ImGui::GetFont()$/;"	f	class:ImGui
GetFontSize	imgui.cpp	/^float ImGui::GetFontSize()$/;"	f	class:ImGui
GetFontTexUvWhitePixel	imgui.cpp	/^ImVec2 ImGui::GetFontTexUvWhitePixel()$/;"	f	class:ImGui
GetFrameCount	imgui.cpp	/^int ImGui::GetFrameCount()$/;"	f	class:ImGui
GetFrontMostModalRootWindow	imgui.cpp	/^static ImGuiWindow* GetFrontMostModalRootWindow()$/;"	f	file:
GetGlyphRangesChinese	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChinese()$/;"	f	class:ImFontAtlas
GetGlyphRangesCyrillic	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()$/;"	f	class:ImFontAtlas
GetGlyphRangesDefault	imgui_draw.cpp	/^const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()$/;"	f	class:ImFontAtlas
GetGlyphRangesJapanese	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()$/;"	f	class:ImFontAtlas
GetGlyphRangesKorean	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()$/;"	f	class:ImFontAtlas
GetHeight	imgui_internal.h	/^    float       GetHeight() const               { return Max.y-Min.y; }$/;"	f	struct:ImRect
GetID	imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id)$/;"	f	class:ImGui
GetID	imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui
GetID	imgui.cpp	/^ImGuiID ImGui::GetID(const void* ptr_id)$/;"	f	class:ImGui
GetID	imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow
GetID	imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const void* ptr)$/;"	f	class:ImGuiWindow
GetIO	imgui.cpp	/^ImGuiIO& ImGui::GetIO()$/;"	f	class:ImGui
GetInt	imgui.cpp	/^int ImGuiStorage::GetInt(ImU32 key, int default_val) const$/;"	f	class:ImGuiStorage
GetIntRef	imgui.cpp	/^int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)$/;"	f	class:ImGuiStorage
GetInternalState	imgui.cpp	/^void* ImGui::GetInternalState()$/;"	f	class:ImGui
GetInternalStateSize	imgui.cpp	/^size_t ImGui::GetInternalStateSize()$/;"	f	class:ImGui
GetItemBoxMax	imgui.h	/^    static inline ImVec2    GetItemBoxMax() { return GetItemRectMax(); }                       \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui
GetItemBoxMin	imgui.h	/^    static inline ImVec2    GetItemBoxMin() { return GetItemRectMin(); }                       \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui
GetItemRectMax	imgui.cpp	/^ImVec2 ImGui::GetItemRectMax()$/;"	f	class:ImGui
GetItemRectMin	imgui.cpp	/^ImVec2 ImGui::GetItemRectMin()$/;"	f	class:ImGui
GetItemRectSize	imgui.cpp	/^ImVec2 ImGui::GetItemRectSize()$/;"	f	class:ImGui
GetItemsLineHeightWithSpacing	imgui.cpp	/^float ImGui::GetItemsLineHeightWithSpacing()$/;"	f	class:ImGui
GetKeyIndex	imgui.cpp	/^int ImGui::GetKeyIndex(ImGuiKey key)$/;"	f	class:ImGui
GetMouseCursor	imgui.cpp	/^ImGuiMouseCursor ImGui::GetMouseCursor()$/;"	f	class:ImGui
GetMouseDragDelta	imgui.cpp	/^ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)$/;"	f	class:ImGui
GetMousePos	imgui.cpp	/^ImVec2 ImGui::GetMousePos()$/;"	f	class:ImGui
GetMousePosOnOpeningCurrentPopup	imgui.cpp	/^ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()$/;"	f	class:ImGui
GetParentWindow	imgui.cpp	/^ImGuiWindow* ImGui::GetParentWindow()$/;"	f	class:ImGui
GetScrollMaxX	imgui.cpp	/^float ImGui::GetScrollMaxX()$/;"	f	class:ImGui
GetScrollMaxY	imgui.cpp	/^float ImGui::GetScrollMaxY()$/;"	f	class:ImGui
GetScrollX	imgui.cpp	/^float ImGui::GetScrollX()$/;"	f	class:ImGui
GetScrollY	imgui.cpp	/^float ImGui::GetScrollY()$/;"	f	class:ImGui
GetSize	imgui_internal.h	/^    ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }$/;"	f	struct:ImRect
GetStateStorage	imgui.cpp	/^ImGuiStorage* ImGui::GetStateStorage()$/;"	f	class:ImGui
GetStyle	imgui.cpp	/^ImGuiStyle& ImGui::GetStyle()$/;"	f	class:ImGui
GetStyleColName	imgui.cpp	/^const char* ImGui::GetStyleColName(ImGuiCol idx)$/;"	f	class:ImGui
GetStyleVarFloatAddr	imgui.cpp	/^static float* GetStyleVarFloatAddr(ImGuiStyleVar idx)$/;"	f	file:
GetStyleVarVec2Addr	imgui.cpp	/^static ImVec2* GetStyleVarVec2Addr(ImGuiStyleVar idx)$/;"	f	file:
GetTL	imgui_internal.h	/^    ImVec2      GetTL() const                   { return Min; }                   \/\/ Top-left$/;"	f	struct:ImRect
GetTR	imgui_internal.h	/^    ImVec2      GetTR() const                   { return ImVec2(Max.x, Min.y); }  \/\/ Top-right$/;"	f	struct:ImRect
GetTexDataAsAlpha8	imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas
GetTexDataAsRGBA32	imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas
GetTextLineHeight	imgui.cpp	/^float ImGui::GetTextLineHeight()$/;"	f	class:ImGui
GetTextLineHeightWithSpacing	imgui.cpp	/^float ImGui::GetTextLineHeightWithSpacing()$/;"	f	class:ImGui
GetTime	imgui.cpp	/^float ImGui::GetTime()$/;"	f	class:ImGui
GetTimeInterval	render2d.cpp	/^float GetTimeInterval() {$/;"	f
GetTimeInterval	render3d.cpp	/^float GetTimeInterval() {$/;"	f
GetVersion	imgui.cpp	/^const char* ImGui::GetVersion()$/;"	f	class:ImGui
GetVisibleRect	imgui.cpp	/^static ImRect GetVisibleRect()$/;"	f	file:
GetVoidPtr	imgui.cpp	/^void* ImGuiStorage::GetVoidPtr(ImGuiID key) const$/;"	f	class:ImGuiStorage
GetVoidPtrRef	imgui.cpp	/^void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)$/;"	f	class:ImGuiStorage
GetWidth	imgui_internal.h	/^    float       GetWidth() const                { return Max.x-Min.x; }$/;"	f	struct:ImRect
GetWindowCollapsed	imgui.h	/^    static inline bool      GetWindowCollapsed() { return ImGui::IsWindowCollapsed(); }        \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui
GetWindowContentRegionMax	imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMax()$/;"	f	class:ImGui
GetWindowContentRegionMin	imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMin()$/;"	f	class:ImGui
GetWindowContentRegionWidth	imgui.cpp	/^float ImGui::GetWindowContentRegionWidth()$/;"	f	class:ImGui
GetWindowDrawList	imgui.cpp	/^ImDrawList* ImGui::GetWindowDrawList()$/;"	f	class:ImGui
GetWindowFont	imgui.h	/^    static inline ImFont*   GetWindowFont() { return GetFont(); }                              \/\/ OBSOLETE 1.48+$/;"	f	namespace:ImGui
GetWindowFontSize	imgui.h	/^    static inline float     GetWindowFontSize() { return GetFontSize(); }                      \/\/ OBSOLETE 1.48+$/;"	f	namespace:ImGui
GetWindowHeight	imgui.cpp	/^float ImGui::GetWindowHeight()$/;"	f	class:ImGui
GetWindowIsFocused	imgui.h	/^    static inline bool      GetWindowIsFocused() { return ImGui::IsWindowFocused(); }          \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui
GetWindowPos	imgui.cpp	/^ImVec2 ImGui::GetWindowPos()$/;"	f	class:ImGui
GetWindowSize	imgui.cpp	/^ImVec2 ImGui::GetWindowSize()$/;"	f	class:ImGui
GetWindowWidth	imgui.cpp	/^float ImGui::GetWindowWidth()$/;"	f	class:ImGui
Glyph	imgui.h	/^    struct Glyph$/;"	s	struct:ImFont
GlyphExtraSpacing	imgui.h	/^    ImVec2          GlyphExtraSpacing;          \/\/ 0, 0     \/\/ Extra spacing (in pixels) between glyphs$/;"	m	struct:ImFontConfig
GlyphRanges	imgui.h	/^    const ImWchar*  GlyphRanges;                \/\/          \/\/ List of Unicode range (2 value per range, values are inclusive, zero-terminated list)$/;"	m	struct:ImFontConfig
Glyphs	imgui.h	/^    ImVector<Glyph>             Glyphs;$/;"	m	struct:ImFont
GrabMinSize	imgui.h	/^    float       GrabMinSize;                \/\/ Minimum width\/height of a grab box for slider\/scrollbar$/;"	m	struct:ImGuiStyle
GrabRounding	imgui.h	/^    float       GrabRounding;               \/\/ Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.$/;"	m	struct:ImGuiStyle
GroupStack	imgui_internal.h	/^    ImVector<ImGuiGroupData>GroupStack;$/;"	m	struct:ImGuiDrawContext
HSV	imgui.h	/^    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }$/;"	f	struct:ImColor
HasSelection	imgui.h	/^    bool    HasSelection() const { return SelectionStart != SelectionEnd; }$/;"	f	struct:ImGuiTextEditCallbackData
HasSelection	imgui_internal.h	/^    bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }$/;"	f	struct:ImGuiTextEditState
HiddenFrames	imgui_internal.h	/^    int                     HiddenFrames;$/;"	m	struct:ImGuiWindow
History	imgui_demo.cpp	/^    ImVector<char*>       History;$/;"	m	struct:ExampleAppConsole	file:
HistoryPos	imgui_demo.cpp	/^    int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:ExampleAppConsole	file:
HotOffset	imgui_internal.h	/^    ImVec2              HotOffset;$/;"	m	struct:ImGuiMouseCursorData
HoveredId	imgui_internal.h	/^    ImGuiID                 HoveredId;                          \/\/ Hovered widget$/;"	m	struct:ImGuiState
HoveredIdAllowOverlap	imgui_internal.h	/^    bool                    HoveredIdAllowOverlap;$/;"	m	struct:ImGuiState
HoveredIdPreviousFrame	imgui_internal.h	/^    ImGuiID                 HoveredIdPreviousFrame;$/;"	m	struct:ImGuiState
HoveredRootWindow	imgui_internal.h	/^    ImGuiWindow*            HoveredRootWindow;                  \/\/ Will catch mouse inputs (for focus\/move only)$/;"	m	struct:ImGuiState
HoveredWindow	imgui_internal.h	/^    ImGuiWindow*            HoveredWindow;                      \/\/ Will catch mouse inputs$/;"	m	struct:ImGuiState
ID	imgui_internal.h	/^    ImGuiID                 ID;$/;"	m	struct:ImGuiWindow
ID	imgui_internal.h	/^    ImGuiID     ID;$/;"	m	struct:ImGuiIniData
IDStack	imgui_internal.h	/^    ImVector<ImGuiID>       IDStack;                            \/\/ ID stack. ID are hashes seeded with the value at the top of the stack$/;"	m	struct:ImGuiWindow
IMGUI_API	imgui.h	23;"	d
IMGUI_DEFINE_MATH_OPERATORS	imgui.cpp	575;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	imgui_draw.cpp	16;"	d	file:
IMGUI_DEFINE_PLACEMENT_NEW	imgui.cpp	576;"	d	file:
IMGUI_DEFINE_PLACEMENT_NEW	imgui_draw.cpp	17;"	d	file:
IMGUI_ONCE_UPON_A_FRAME	imgui.h	861;"	d
IMGUI_STB_NAMESPACE	imgui_draw.cpp	/^namespace IMGUI_STB_NAMESPACE$/;"	n	file:
IMGUI_VERSION	imgui.h	19;"	d
IM_ARRAYSIZE	imgui_demo.cpp	44;"	d	file:
IM_ARRAYSIZE	imgui_internal.h	80;"	d
IM_ARRAYSIZE	ui.h	9;"	d
IM_ASSERT	imgui.h	29;"	d
IM_COL32	imgui.h	1049;"	d
IM_COL32_BLACK	imgui.h	1051;"	d
IM_COL32_BLACK_TRANS	imgui.h	1052;"	d
IM_COL32_WHITE	imgui.h	1050;"	d
IM_F32_TO_INT8	imgui.cpp	835;"	d	file:
IM_INT_MAX	imgui.cpp	838;"	d	file:
IM_INT_MIN	imgui.cpp	837;"	d	file:
IM_NEWLINE	imgui.cpp	842;"	d	file:
IM_NEWLINE	imgui.cpp	844;"	d	file:
IM_NEWLINE	imgui_demo.cpp	39;"	d	file:
IM_NEWLINE	imgui_demo.cpp	41;"	d	file:
IM_PI	imgui_internal.h	81;"	d
IM_PLACEMENT_NEW	imgui_internal.h	146;"	d
IM_PRINTFARGS	imgui.h	34;"	d
IM_PRINTFARGS	imgui.h	36;"	d
INC	Makefile	/^INC=`sdl2-config --cflags` -I \/usr\/include$/;"	m
INCLUDE_STB_TEXTEDIT_H	stb_textedit.h	269;"	d
INPUT	render2d.cpp	18;"	d	file:
INPUT	render3d.cpp	18;"	d	file:
INX_TYPE	palace.h	17795;"	d
INX_TYPE	untitled.h	5767;"	d
IO	imgui_internal.h	/^    ImGuiIO                 IO;$/;"	m	struct:ImGuiState
Id	imgui_internal.h	/^    ImGuiID             Id;                         \/\/ widget id owning the text state$/;"	m	struct:ImGuiTextEditState
IdxBuffer	imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;          \/\/ Index buffer. Each command consume ImDrawCmd::ElemCount of those$/;"	m	struct:ImDrawList
IdxBuffer	imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;$/;"	m	struct:ImDrawChannel
ImCharIsSpace	imgui_internal.h	/^static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\\t' || c == 0x3000; }$/;"	f
ImClamp	imgui_internal.h	/^static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }$/;"	f
ImClamp	imgui_internal.h	/^static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }$/;"	f
ImClamp	imgui_internal.h	/^static inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }$/;"	f
ImColor	imgui.h	/^    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^    ImColor(ImU32 rgba)                                             { float sc = 1.0f\/255.0f; Value.x = (float)(rgba&0xFF) * sc; Value.y = (float)((rgba>>8)&0xFF) * sc; Value.z = (float)((rgba>>16)&0xFF) * sc; Value.w = (float)(rgba >> 24) * sc; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^    ImColor(const ImVec4& col)                                      { Value = col; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f\/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^struct ImColor$/;"	s
ImDrawCallback	imgui.h	/^typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);$/;"	t
ImDrawChannel	imgui.h	/^struct ImDrawChannel$/;"	s
ImDrawCmd	imgui.h	/^    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = -8192.0f; ClipRect.z = ClipRect.w = +8192.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }$/;"	f	struct:ImDrawCmd
ImDrawCmd	imgui.h	/^struct ImDrawCmd$/;"	s
ImDrawData	imgui.h	/^    ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }$/;"	f	struct:ImDrawData
ImDrawData	imgui.h	/^struct ImDrawData$/;"	s
ImDrawIdx	imgui.h	/^typedef unsigned short ImDrawIdx;$/;"	t
ImDrawList	imgui.h	/^    ImDrawList() { _OwnerName = NULL; Clear(); }$/;"	f	struct:ImDrawList
ImDrawList	imgui.h	/^struct ImDrawList$/;"	s
ImDrawVert	imgui.h	/^struct ImDrawVert$/;"	s
ImFont	imgui.h	/^struct ImFont$/;"	s
ImFont	imgui_draw.cpp	/^ImFont::ImFont()$/;"	f	class:ImFont
ImFontAtlas	imgui.h	/^struct ImFontAtlas$/;"	s
ImFontAtlas	imgui_draw.cpp	/^ImFontAtlas::ImFontAtlas()$/;"	f	class:ImFontAtlas
ImFontConfig	imgui.h	/^struct ImFontConfig$/;"	s
ImFontConfig	imgui_draw.cpp	/^ImFontConfig::ImFontConfig()$/;"	f	class:ImFontConfig
ImFormatString	imgui.cpp	/^int ImFormatString(char* buf, int buf_size, const char* fmt, ...)$/;"	f
ImFormatStringV	imgui.cpp	/^int ImFormatStringV(char* buf, int buf_size, const char* fmt, va_list args)$/;"	f
ImGui	imgui.h	/^namespace ImGui$/;"	n
ImGui	imgui_internal.h	/^namespace ImGui$/;"	n
ImGuiAlign	imgui.h	/^typedef int ImGuiAlign;             \/\/ alignment                            \/\/ enum ImGuiAlign_$/;"	t
ImGuiAlign_	imgui.h	/^enum ImGuiAlign_$/;"	g
ImGuiAlign_Center	imgui.h	/^    ImGuiAlign_Center   = 1 << 1,$/;"	e	enum:ImGuiAlign_
ImGuiAlign_Default	imgui.h	/^    ImGuiAlign_Default  = ImGuiAlign_Left | ImGuiAlign_Top$/;"	e	enum:ImGuiAlign_
ImGuiAlign_Left	imgui.h	/^    ImGuiAlign_Left     = 1 << 0,$/;"	e	enum:ImGuiAlign_
ImGuiAlign_Right	imgui.h	/^    ImGuiAlign_Right    = 1 << 2,$/;"	e	enum:ImGuiAlign_
ImGuiAlign_Top	imgui.h	/^    ImGuiAlign_Top      = 1 << 3,$/;"	e	enum:ImGuiAlign_
ImGuiAlign_VCenter	imgui.h	/^    ImGuiAlign_VCenter  = 1 << 4,$/;"	e	enum:ImGuiAlign_
ImGuiButtonFlags	imgui_internal.h	/^typedef int ImGuiButtonFlags;     \/\/ enum ImGuiButtonFlags_$/;"	t
ImGuiButtonFlags_	imgui_internal.h	/^enum ImGuiButtonFlags_$/;"	g
ImGuiButtonFlags_AlignTextBaseLine	imgui_internal.h	/^    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 7,   \/\/ vertically align button to match text baseline - ButtonEx() only$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_Disabled	imgui_internal.h	/^    ImGuiButtonFlags_Disabled               = 1 << 6,   \/\/ disable interaction$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_DontClosePopups	imgui_internal.h	/^    ImGuiButtonFlags_DontClosePopups        = 1 << 5,   \/\/ disable automatically closing parent popup on press$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_FlattenChilds	imgui_internal.h	/^    ImGuiButtonFlags_FlattenChilds          = 1 << 4,   \/\/ allow interaction even if a child window is overlapping$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_NoKeyModifiers	imgui_internal.h	/^    ImGuiButtonFlags_NoKeyModifiers         = 1 << 8    \/\/ disable interaction if a key modifier is held$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnClick	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnClick         = 1 << 1,   \/\/ return pressed on click (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnDoubleClick	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 3,   \/\/ return pressed on double-click (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnRelease	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnRelease       = 1 << 2,   \/\/ return pressed on release (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_Repeat	imgui_internal.h	/^    ImGuiButtonFlags_Repeat                 = 1 << 0,   \/\/ hold to repeat$/;"	e	enum:ImGuiButtonFlags_
ImGuiCol	imgui.h	/^typedef int ImGuiCol;               \/\/ a color identifier for styling       \/\/ enum ImGuiCol_$/;"	t
ImGuiColMod	imgui_internal.h	/^struct ImGuiColMod$/;"	s
ImGuiCol_	imgui.h	/^enum ImGuiCol_$/;"	g
ImGuiCol_Border	imgui.h	/^    ImGuiCol_Border,$/;"	e	enum:ImGuiCol_
ImGuiCol_BorderShadow	imgui.h	/^    ImGuiCol_BorderShadow,$/;"	e	enum:ImGuiCol_
ImGuiCol_Button	imgui.h	/^    ImGuiCol_Button,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonActive	imgui.h	/^    ImGuiCol_ButtonActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonHovered	imgui.h	/^    ImGuiCol_ButtonHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_COUNT	imgui.h	/^    ImGuiCol_COUNT$/;"	e	enum:ImGuiCol_
ImGuiCol_CheckMark	imgui.h	/^    ImGuiCol_CheckMark,$/;"	e	enum:ImGuiCol_
ImGuiCol_ChildWindowBg	imgui.h	/^    ImGuiCol_ChildWindowBg,         \/\/ Background of child windows$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButton	imgui.h	/^    ImGuiCol_CloseButton,$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButtonActive	imgui.h	/^    ImGuiCol_CloseButtonActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButtonHovered	imgui.h	/^    ImGuiCol_CloseButtonHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Column	imgui.h	/^    ImGuiCol_Column,$/;"	e	enum:ImGuiCol_
ImGuiCol_ColumnActive	imgui.h	/^    ImGuiCol_ColumnActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ColumnHovered	imgui.h	/^    ImGuiCol_ColumnHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ComboBg	imgui.h	/^    ImGuiCol_ComboBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBg	imgui.h	/^    ImGuiCol_FrameBg,               \/\/ Background of checkbox, radio button, plot, slider, text input$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgActive	imgui.h	/^    ImGuiCol_FrameBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgHovered	imgui.h	/^    ImGuiCol_FrameBgHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Header	imgui.h	/^    ImGuiCol_Header,$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderActive	imgui.h	/^    ImGuiCol_HeaderActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderHovered	imgui.h	/^    ImGuiCol_HeaderHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_MenuBarBg	imgui.h	/^    ImGuiCol_MenuBarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ModalWindowDarkening	imgui.h	/^    ImGuiCol_ModalWindowDarkening,  \/\/ darken entire screen when a modal window is active$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogram	imgui.h	/^    ImGuiCol_PlotHistogram,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogramHovered	imgui.h	/^    ImGuiCol_PlotHistogramHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLines	imgui.h	/^    ImGuiCol_PlotLines,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLinesHovered	imgui.h	/^    ImGuiCol_PlotLinesHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PopupBg	imgui.h	/^    ImGuiCol_PopupBg,               \/\/ Background of popups, menus, tooltips windows$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGrip	imgui.h	/^    ImGuiCol_ResizeGrip,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripActive	imgui.h	/^    ImGuiCol_ResizeGripActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripHovered	imgui.h	/^    ImGuiCol_ResizeGripHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarBg	imgui.h	/^    ImGuiCol_ScrollbarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrab	imgui.h	/^    ImGuiCol_ScrollbarGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabActive	imgui.h	/^    ImGuiCol_ScrollbarGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabHovered	imgui.h	/^    ImGuiCol_ScrollbarGrabHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrab	imgui.h	/^    ImGuiCol_SliderGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrabActive	imgui.h	/^    ImGuiCol_SliderGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_Text	imgui.h	/^    ImGuiCol_Text,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextDisabled	imgui.h	/^    ImGuiCol_TextDisabled,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextSelectedBg	imgui.h	/^    ImGuiCol_TextSelectedBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBg	imgui.h	/^    ImGuiCol_TitleBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgActive	imgui.h	/^    ImGuiCol_TitleBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgCollapsed	imgui.h	/^    ImGuiCol_TitleBgCollapsed,$/;"	e	enum:ImGuiCol_
ImGuiCol_WindowBg	imgui.h	/^    ImGuiCol_WindowBg,              \/\/ Background of normal windows$/;"	e	enum:ImGuiCol_
ImGuiColorEditMode	imgui.h	/^typedef int ImGuiColorEditMode;     \/\/ color edit mode for ColorEdit*()     \/\/ enum ImGuiColorEditMode_$/;"	t
ImGuiColorEditMode_	imgui.h	/^enum ImGuiColorEditMode_$/;"	g
ImGuiColorEditMode_HEX	imgui.h	/^    ImGuiColorEditMode_HEX = 2$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_HSV	imgui.h	/^    ImGuiColorEditMode_HSV = 1,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_RGB	imgui.h	/^    ImGuiColorEditMode_RGB = 0,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_UserSelect	imgui.h	/^    ImGuiColorEditMode_UserSelect = -2,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_UserSelectShowButton	imgui.h	/^    ImGuiColorEditMode_UserSelectShowButton = -1,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColumnData	imgui_internal.h	/^struct ImGuiColumnData$/;"	s
ImGuiDataType	imgui_internal.h	/^enum ImGuiDataType$/;"	g
ImGuiDataType_Float	imgui_internal.h	/^    ImGuiDataType_Float$/;"	e	enum:ImGuiDataType
ImGuiDataType_Int	imgui_internal.h	/^    ImGuiDataType_Int,$/;"	e	enum:ImGuiDataType
ImGuiDrawContext	imgui_internal.h	/^    ImGuiDrawContext()$/;"	f	struct:ImGuiDrawContext
ImGuiDrawContext	imgui_internal.h	/^struct IMGUI_API ImGuiDrawContext$/;"	s
ImGuiGroupData	imgui_internal.h	/^struct ImGuiGroupData$/;"	s
ImGuiID	imgui.h	/^typedef ImU32 ImGuiID;              \/\/ unique ID used by widgets (typically hashed from a stack of string)$/;"	t
ImGuiIO	imgui.cpp	/^ImGuiIO::ImGuiIO()$/;"	f	class:ImGuiIO
ImGuiIO	imgui.h	/^struct ImGuiIO$/;"	s
ImGuiIniData	imgui_internal.h	/^struct ImGuiIniData$/;"	s
ImGuiInputTextFlags	imgui.h	/^typedef int ImGuiInputTextFlags;    \/\/ flags for InputText*()               \/\/ enum ImGuiInputTextFlags_$/;"	t
ImGuiInputTextFlags_	imgui.h	/^enum ImGuiInputTextFlags_$/;"	g
ImGuiInputTextFlags_AllowTabInput	imgui.h	/^    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  \/\/ Pressing TAB input a '\\t' character into the text field$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AlwaysInsertMode	imgui.h	/^    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  \/\/ Insert mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AutoSelectAll	imgui.h	/^    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   \/\/ Select entire text when first taking mouse focus$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackAlways	imgui.h	/^    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   \/\/ Call user function every time. User code may query cursor position, modify text buffer.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCharFilter	imgui.h	/^    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   \/\/ Call user function to filter character. Modify data->EventChar to replace\/filter input, or return 1 to discard character.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCompletion	imgui.h	/^    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   \/\/ Call user function on pressing TAB (for completion handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackHistory	imgui.h	/^    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   \/\/ Call user function on pressing Up\/Down arrows (for history handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsDecimal	imgui.h	/^    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   \/\/ Allow 0123456789.+-*\/$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsHexadecimal	imgui.h	/^    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   \/\/ Allow 0123456789ABCDEFabcdef$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsNoBlank	imgui.h	/^    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   \/\/ Filter out spaces, tabs$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsUppercase	imgui.h	/^    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   \/\/ Turn a..z into A..Z$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CtrlEnterForNewLine	imgui.h	/^    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  \/\/ In multi-line mode, allow exiting edition by pressing Enter. Ctrl+Enter to add new line (by default adds new lines with Enter).$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_EnterReturnsTrue	imgui.h	/^    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   \/\/ Return 'true' when Enter is pressed (as opposed to when the value was modified)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Multiline	imgui.h	/^    ImGuiInputTextFlags_Multiline           = 1 << 20   \/\/ For internal use by InputTextMultiline()$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoHorizontalScroll	imgui.h	/^    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  \/\/ Disable following the cursor horizontally$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Password	imgui.h	/^    ImGuiInputTextFlags_Password            = 1 << 15,  \/\/ Password mode, display all characters as '*'$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_ReadOnly	imgui.h	/^    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  \/\/ Read-only mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiKey	imgui.h	/^typedef int ImGuiKey;               \/\/ a key identifier (ImGui-side enum)   \/\/ enum ImGuiKey_$/;"	t
ImGuiKey_	imgui.h	/^enum ImGuiKey_$/;"	g
ImGuiKey_A	imgui.h	/^    ImGuiKey_A,         \/\/ for text edit CTRL+A: select all$/;"	e	enum:ImGuiKey_
ImGuiKey_Backspace	imgui.h	/^    ImGuiKey_Backspace, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_C	imgui.h	/^    ImGuiKey_C,         \/\/ for text edit CTRL+C: copy$/;"	e	enum:ImGuiKey_
ImGuiKey_COUNT	imgui.h	/^    ImGuiKey_COUNT$/;"	e	enum:ImGuiKey_
ImGuiKey_Delete	imgui.h	/^    ImGuiKey_Delete,    \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_DownArrow	imgui.h	/^    ImGuiKey_DownArrow, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_End	imgui.h	/^    ImGuiKey_End,       \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Enter	imgui.h	/^    ImGuiKey_Enter,     \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Escape	imgui.h	/^    ImGuiKey_Escape,    \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Home	imgui.h	/^    ImGuiKey_Home,      \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_LeftArrow	imgui.h	/^    ImGuiKey_LeftArrow, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_PageDown	imgui.h	/^    ImGuiKey_PageDown,$/;"	e	enum:ImGuiKey_
ImGuiKey_PageUp	imgui.h	/^    ImGuiKey_PageUp,$/;"	e	enum:ImGuiKey_
ImGuiKey_RightArrow	imgui.h	/^    ImGuiKey_RightArrow,\/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Tab	imgui.h	/^    ImGuiKey_Tab,       \/\/ for tabbing through fields$/;"	e	enum:ImGuiKey_
ImGuiKey_UpArrow	imgui.h	/^    ImGuiKey_UpArrow,   \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_V	imgui.h	/^    ImGuiKey_V,         \/\/ for text edit CTRL+V: paste$/;"	e	enum:ImGuiKey_
ImGuiKey_X	imgui.h	/^    ImGuiKey_X,         \/\/ for text edit CTRL+X: cut$/;"	e	enum:ImGuiKey_
ImGuiKey_Y	imgui.h	/^    ImGuiKey_Y,         \/\/ for text edit CTRL+Y: redo$/;"	e	enum:ImGuiKey_
ImGuiKey_Z	imgui.h	/^    ImGuiKey_Z,         \/\/ for text edit CTRL+Z: undo$/;"	e	enum:ImGuiKey_
ImGuiLayoutType	imgui_internal.h	/^typedef int ImGuiLayoutType;      \/\/ enum ImGuiLayoutType_$/;"	t
ImGuiLayoutType_	imgui_internal.h	/^enum ImGuiLayoutType_$/;"	g
ImGuiLayoutType_Horizontal	imgui_internal.h	/^    ImGuiLayoutType_Horizontal$/;"	e	enum:ImGuiLayoutType_
ImGuiLayoutType_Vertical	imgui_internal.h	/^    ImGuiLayoutType_Vertical,$/;"	e	enum:ImGuiLayoutType_
ImGuiListClipper	imgui.h	/^    ImGuiListClipper()                         { ItemsHeight = 0.0f; ItemsCount = DisplayStart = DisplayEnd = -1; }$/;"	f	struct:ImGuiListClipper
ImGuiListClipper	imgui.h	/^    ImGuiListClipper(int count, float height)  { ItemsCount = -1; Begin(count, height); }$/;"	f	struct:ImGuiListClipper
ImGuiListClipper	imgui.h	/^struct ImGuiListClipper$/;"	s
ImGuiMouseCursor	imgui.h	/^typedef int ImGuiMouseCursor;       \/\/ a mouse cursor identifier            \/\/ enum ImGuiMouseCursor_$/;"	t
ImGuiMouseCursorData	imgui_internal.h	/^struct ImGuiMouseCursorData$/;"	s
ImGuiMouseCursor_	imgui.h	/^enum ImGuiMouseCursor_$/;"	g
ImGuiMouseCursor_Arrow	imgui.h	/^    ImGuiMouseCursor_Arrow = 0,$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Count_	imgui.h	/^    ImGuiMouseCursor_Count_$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Move	imgui.h	/^    ImGuiMouseCursor_Move,              \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeEW	imgui.h	/^    ImGuiMouseCursor_ResizeEW,          \/\/ When hovering over a column$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNESW	imgui.h	/^    ImGuiMouseCursor_ResizeNESW,        \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNS	imgui.h	/^    ImGuiMouseCursor_ResizeNS,          \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNWSE	imgui.h	/^    ImGuiMouseCursor_ResizeNWSE,        \/\/ When hovering over the bottom-right corner of a window$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_TextInput	imgui.h	/^    ImGuiMouseCursor_TextInput,         \/\/ When hovering over InputText, etc.$/;"	e	enum:ImGuiMouseCursor_
ImGuiOnceUponAFrame	imgui.h	/^    ImGuiOnceUponAFrame() { RefFrame = -1; }$/;"	f	struct:ImGuiOnceUponAFrame
ImGuiOnceUponAFrame	imgui.h	/^struct ImGuiOnceUponAFrame$/;"	s
ImGuiPlotArrayGetterData	imgui.cpp	/^    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }$/;"	f	struct:ImGuiPlotArrayGetterData
ImGuiPlotArrayGetterData	imgui.cpp	/^struct ImGuiPlotArrayGetterData$/;"	s	file:
ImGuiPlotType	imgui_internal.h	/^enum ImGuiPlotType$/;"	g
ImGuiPlotType_Histogram	imgui_internal.h	/^    ImGuiPlotType_Histogram$/;"	e	enum:ImGuiPlotType
ImGuiPlotType_Lines	imgui_internal.h	/^    ImGuiPlotType_Lines,$/;"	e	enum:ImGuiPlotType
ImGuiPopupRef	imgui_internal.h	/^    ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& mouse_pos) { PopupID = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; MousePosOnOpen = mouse_pos; }$/;"	f	struct:ImGuiPopupRef
ImGuiPopupRef	imgui_internal.h	/^struct ImGuiPopupRef$/;"	s
ImGuiSelectableFlags	imgui.h	/^typedef int ImGuiSelectableFlags;   \/\/ flags for Selectable()               \/\/ enum ImGuiSelectableFlags_$/;"	t
ImGuiSelectableFlagsPrivate_	imgui_internal.h	/^enum ImGuiSelectableFlagsPrivate_$/;"	g
ImGuiSelectableFlags_	imgui.h	/^enum ImGuiSelectableFlags_$/;"	g
ImGuiSelectableFlags_AllowDoubleClick	imgui.h	/^    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2    \/\/ Generate press events on double clicks too$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_Disabled	imgui_internal.h	/^    ImGuiSelectableFlags_Disabled           = 1 << 5,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_DontClosePopups	imgui.h	/^    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   \/\/ Clicking this don't close parent popup window$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_DrawFillAvailWidth	imgui_internal.h	/^    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 6$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_Menu	imgui_internal.h	/^    ImGuiSelectableFlags_Menu               = 1 << 3,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_MenuItem	imgui_internal.h	/^    ImGuiSelectableFlags_MenuItem           = 1 << 4,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_SpanAllColumns	imgui.h	/^    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   \/\/ Selectable frame can span all columns (text will still fit in current column)$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSetCond	imgui.h	/^typedef int ImGuiSetCond;           \/\/ condition flags for Set*()           \/\/ enum ImGuiSetCond_$/;"	t
ImGuiSetCond_	imgui.h	/^enum ImGuiSetCond_$/;"	g
ImGuiSetCond_Always	imgui.h	/^    ImGuiSetCond_Always        = 1 << 0, \/\/ Set the variable$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_Appearing	imgui.h	/^    ImGuiSetCond_Appearing     = 1 << 3  \/\/ Only set the variable if the window is appearing after being inactive (or the first time)$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_FirstUseEver	imgui.h	/^    ImGuiSetCond_FirstUseEver  = 1 << 2, \/\/ Only set the variable if the window doesn't exist in the .ini file$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_Once	imgui.h	/^    ImGuiSetCond_Once          = 1 << 1, \/\/ Only set the variable on the first call per runtime session$/;"	e	enum:ImGuiSetCond_
ImGuiSimpleColumns	imgui.cpp	/^ImGuiSimpleColumns::ImGuiSimpleColumns()$/;"	f	class:ImGuiSimpleColumns
ImGuiSimpleColumns	imgui_internal.h	/^struct IMGUI_API ImGuiSimpleColumns$/;"	s
ImGuiSliderFlags	imgui_internal.h	/^typedef int ImGuiSliderFlags;     \/\/ enum ImGuiSliderFlags_$/;"	t
ImGuiSliderFlags_	imgui_internal.h	/^enum ImGuiSliderFlags_$/;"	g
ImGuiSliderFlags_Vertical	imgui_internal.h	/^    ImGuiSliderFlags_Vertical               = 1 << 0$/;"	e	enum:ImGuiSliderFlags_
ImGuiState	imgui_internal.h	/^    ImGuiState()$/;"	f	struct:ImGuiState
ImGuiState	imgui_internal.h	/^struct ImGuiState$/;"	s
ImGuiStb	imgui.cpp	/^namespace ImGuiStb$/;"	n	file:
ImGuiStb	imgui_internal.h	/^namespace ImGuiStb$/;"	n
ImGuiStorage	imgui.h	/^struct ImGuiStorage$/;"	s
ImGuiStyle	imgui.cpp	/^ImGuiStyle::ImGuiStyle()$/;"	f	class:ImGuiStyle
ImGuiStyle	imgui.h	/^struct ImGuiStyle$/;"	s
ImGuiStyleMod	imgui_internal.h	/^struct ImGuiStyleMod$/;"	s
ImGuiStyleVar	imgui.h	/^typedef int ImGuiStyleVar;          \/\/ a variable identifier for styling    \/\/ enum ImGuiStyleVar_$/;"	t
ImGuiStyleVar_	imgui.h	/^enum ImGuiStyleVar_$/;"	g
ImGuiStyleVar_Alpha	imgui.h	/^    ImGuiStyleVar_Alpha,               \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ChildWindowRounding	imgui.h	/^    ImGuiStyleVar_ChildWindowRounding, \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FramePadding	imgui.h	/^    ImGuiStyleVar_FramePadding,        \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FrameRounding	imgui.h	/^    ImGuiStyleVar_FrameRounding,       \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_GrabMinSize	imgui.h	/^    ImGuiStyleVar_GrabMinSize          \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_IndentSpacing	imgui.h	/^    ImGuiStyleVar_IndentSpacing,       \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemInnerSpacing	imgui.h	/^    ImGuiStyleVar_ItemInnerSpacing,    \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemSpacing	imgui.h	/^    ImGuiStyleVar_ItemSpacing,         \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowMinSize	imgui.h	/^    ImGuiStyleVar_WindowMinSize,       \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowPadding	imgui.h	/^    ImGuiStyleVar_WindowPadding,       \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowRounding	imgui.h	/^    ImGuiStyleVar_WindowRounding,      \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiTextBuffer	imgui.h	/^    ImGuiTextBuffer()   { Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer
ImGuiTextBuffer	imgui.h	/^struct ImGuiTextBuffer$/;"	s
ImGuiTextEditCallback	imgui.h	/^typedef int (*ImGuiTextEditCallback)(ImGuiTextEditCallbackData *data);$/;"	t
ImGuiTextEditCallbackData	imgui.h	/^struct ImGuiTextEditCallbackData$/;"	s
ImGuiTextEditState	imgui_internal.h	/^    ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTextEditState
ImGuiTextEditState	imgui_internal.h	/^struct IMGUI_API ImGuiTextEditState$/;"	s
ImGuiTextFilter	imgui.cpp	/^ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)$/;"	f	class:ImGuiTextFilter
ImGuiTextFilter	imgui.h	/^struct ImGuiTextFilter$/;"	s
ImGuiTreeNodeFlags	imgui_internal.h	/^typedef int ImGuiTreeNodeFlags;   \/\/ enum ImGuiTreeNodeFlags_$/;"	t
ImGuiTreeNodeFlags_	imgui_internal.h	/^enum ImGuiTreeNodeFlags_$/;"	g
ImGuiTreeNodeFlags_DefaultOpen	imgui_internal.h	/^    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 0,$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NoAutoExpandOnLog	imgui_internal.h	/^    ImGuiTreeNodeFlags_NoAutoExpandOnLog    = 1 << 1$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiWindow	imgui.cpp	/^ImGuiWindow::ImGuiWindow(const char* name)$/;"	f	class:ImGuiWindow
ImGuiWindow	imgui_internal.h	/^struct IMGUI_API ImGuiWindow$/;"	s
ImGuiWindowFlags	imgui.h	/^typedef int ImGuiWindowFlags;       \/\/ window flags for Begin*()            \/\/ enum ImGuiWindowFlags_$/;"	t
ImGuiWindowFlags_	imgui.h	/^enum ImGuiWindowFlags_$/;"	g
ImGuiWindowFlags_AlwaysAutoResize	imgui.h	/^    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   \/\/ Resize every window to its content every frame$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysHorizontalScrollbar	imgui.h	/^    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  \/\/ Always show horizontal scrollbar (even if ContentSize.x < Size.x)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysUseWindowPadding	imgui.h	/^    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  \/\/ Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysVerticalScrollbar	imgui.h	/^    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  \/\/ Always show vertical scrollbar (even if ContentSize.y < Size.y)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildMenu	imgui.h	/^    ImGuiWindowFlags_ChildMenu              = 1 << 27   \/\/ Don't use! For internal use by BeginMenu()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindow	imgui.h	/^    ImGuiWindowFlags_ChildWindow            = 1 << 20,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindowAutoFitX	imgui.h	/^    ImGuiWindowFlags_ChildWindowAutoFitX    = 1 << 21,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindowAutoFitY	imgui.h	/^    ImGuiWindowFlags_ChildWindowAutoFitY    = 1 << 22,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ComboBox	imgui.h	/^    ImGuiWindowFlags_ComboBox               = 1 << 23,  \/\/ Don't use! For internal use by ComboBox()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_HorizontalScrollbar	imgui.h	/^    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  \/\/ Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_MenuBar	imgui.h	/^    ImGuiWindowFlags_MenuBar                = 1 << 10,  \/\/ Has a menu-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Modal	imgui.h	/^    ImGuiWindowFlags_Modal                  = 1 << 26,  \/\/ Don't use! For internal use by BeginPopupModal()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoBringToFrontOnFocus	imgui.h	/^    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  \/\/ Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoCollapse	imgui.h	/^    ImGuiWindowFlags_NoCollapse             = 1 << 5,   \/\/ Disable user collapsing window by double-clicking on it$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoFocusOnAppearing	imgui.h	/^    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  \/\/ Disable taking focus when transitioning from hidden to visible state$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoInputs	imgui.h	/^    ImGuiWindowFlags_NoInputs               = 1 << 9,   \/\/ Disable catching mouse or keyboard inputs$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoMove	imgui.h	/^    ImGuiWindowFlags_NoMove                 = 1 << 2,   \/\/ Disable user moving the window$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoResize	imgui.h	/^    ImGuiWindowFlags_NoResize               = 1 << 1,   \/\/ Disable user resizing with the lower-right grip$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoSavedSettings	imgui.h	/^    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   \/\/ Never load\/save settings in .ini file$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollWithMouse	imgui.h	/^    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   \/\/ Disable user vertically scrolling with mouse wheel$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollbar	imgui.h	/^    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   \/\/ Disable scrollbars (window can still scroll with mouse or programatically)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoTitleBar	imgui.h	/^    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   \/\/ Disable title-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Popup	imgui.h	/^    ImGuiWindowFlags_Popup                  = 1 << 25,  \/\/ Don't use! For internal use by BeginPopup()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ShowBorders	imgui.h	/^    ImGuiWindowFlags_ShowBorders            = 1 << 7,   \/\/ Show borders around windows and items$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Tooltip	imgui.h	/^    ImGuiWindowFlags_Tooltip                = 1 << 24,  \/\/ Don't use! For internal use by BeginTooltip()$/;"	e	enum:ImGuiWindowFlags_
ImGui_ImplSdl_CreateDeviceObjects	imgui_impl_sdl.cpp	/^bool ImGui_ImplSdl_CreateDeviceObjects()$/;"	f
ImGui_ImplSdl_GetClipboardText	imgui_impl_sdl.cpp	/^static const char* ImGui_ImplSdl_GetClipboardText()$/;"	f	file:
ImGui_ImplSdl_Init	imgui_impl_sdl.cpp	/^bool    ImGui_ImplSdl_Init(SDL_Window* window)$/;"	f
ImGui_ImplSdl_InvalidateDeviceObjects	imgui_impl_sdl.cpp	/^void    ImGui_ImplSdl_InvalidateDeviceObjects()$/;"	f
ImGui_ImplSdl_NewFrame	imgui_impl_sdl.cpp	/^void ImGui_ImplSdl_NewFrame(SDL_Window *window)$/;"	f
ImGui_ImplSdl_ProcessEvent	imgui_impl_sdl.cpp	/^bool ImGui_ImplSdl_ProcessEvent(SDL_Event* event)$/;"	f
ImGui_ImplSdl_RenderDrawLists	imgui_impl_sdl.cpp	/^void ImGui_ImplSdl_RenderDrawLists(ImDrawData* draw_data)$/;"	f
ImGui_ImplSdl_SetClipboardText	imgui_impl_sdl.cpp	/^static void ImGui_ImplSdl_SetClipboardText(const char* text)$/;"	f	file:
ImGui_ImplSdl_Shutdown	imgui_impl_sdl.cpp	/^void ImGui_ImplSdl_Shutdown()$/;"	f
ImHash	imgui.cpp	/^ImU32 ImHash(const void* data, int data_size, ImU32 seed)$/;"	f
ImInvLength	imgui_internal.h	/^static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f \/ sqrtf(d); return fail_value; }$/;"	f
ImIsPointInTriangle	imgui.cpp	/^bool ImIsPointInTriangle(const ImVec2& p, const ImVec2& a, const ImVec2& b, const ImVec2& c)$/;"	f
ImLengthSqr	imgui_internal.h	/^static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }$/;"	f
ImLengthSqr	imgui_internal.h	/^static inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }$/;"	f
ImLerp	imgui_internal.h	/^static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }$/;"	f
ImLerp	imgui_internal.h	/^static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }$/;"	f
ImLoadFileToMemory	imgui.cpp	/^void* ImLoadFileToMemory(const char* filename, const char* file_open_mode, int* out_file_size, int padding_bytes)$/;"	f
ImMax	imgui_internal.h	/^static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMax(lhs.x,rhs.x), ImMax(lhs.y,rhs.y)); }$/;"	f
ImMax	imgui_internal.h	/^static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }$/;"	f
ImMax	imgui_internal.h	/^static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }$/;"	f
ImMin	imgui_internal.h	/^static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMin(lhs.x,rhs.x), ImMin(lhs.y,rhs.y)); }$/;"	f
ImMin	imgui_internal.h	/^static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }$/;"	f
ImMin	imgui_internal.h	/^static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }$/;"	f
ImPlacementNewDummy	imgui_internal.h	/^struct ImPlacementNewDummy {};$/;"	s
ImRect	imgui_internal.h	/^    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}$/;"	f	struct:ImRect
ImRect	imgui_internal.h	/^    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}$/;"	f	struct:ImRect
ImRect	imgui_internal.h	/^    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}$/;"	f	struct:ImRect
ImRect	imgui_internal.h	/^    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}$/;"	f	struct:ImRect
ImRect	imgui_internal.h	/^struct IMGUI_API ImRect$/;"	s
ImRound	imgui_internal.h	/^static inline ImVec2 ImRound(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }$/;"	f
ImSaturate	imgui_internal.h	/^static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }$/;"	f
ImStrbolW	imgui.cpp	/^const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) \/\/ find beginning-of-line$/;"	f
ImStrdup	imgui.cpp	/^char* ImStrdup(const char *str)$/;"	f
ImStricmp	imgui.cpp	/^int ImStricmp(const char* str1, const char* str2)$/;"	f
ImStristr	imgui.cpp	/^const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)$/;"	f
ImStrlenW	imgui.cpp	/^int ImStrlenW(const ImWchar* str)$/;"	f
ImStrnicmp	imgui.cpp	/^int ImStrnicmp(const char* str1, const char* str2, int count)$/;"	f
ImTextCharFromUtf8	imgui.cpp	/^int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)$/;"	f
ImTextCharToUtf8	imgui.cpp	/^static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)$/;"	f	file:
ImTextCountCharsFromUtf8	imgui.cpp	/^int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)$/;"	f
ImTextCountUtf8BytesFromChar	imgui.cpp	/^static inline int ImTextCountUtf8BytesFromChar(unsigned int c)$/;"	f	file:
ImTextCountUtf8BytesFromStr	imgui.cpp	/^int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f
ImTextStrFromUtf8	imgui.cpp	/^int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)$/;"	f
ImTextStrToUtf8	imgui.cpp	/^int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f
ImTextureID	imgui.h	/^typedef void* ImTextureID;          \/\/ user data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)$/;"	t
ImU32	imgui.h	/^typedef unsigned int ImU32;$/;"	t
ImUpperPowerOfTwo	imgui_internal.h	/^static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }$/;"	f
ImVec2	imgui.h	/^    ImVec2() { x = y = 0.0f; }$/;"	f	struct:ImVec2
ImVec2	imgui.h	/^    ImVec2(float _x, float _y) { x = _x; y = _y; }$/;"	f	struct:ImVec2
ImVec2	imgui.h	/^struct ImVec2$/;"	s
ImVec4	imgui.h	/^    ImVec4() { x = y = z = w = 0.0f; }$/;"	f	struct:ImVec4
ImVec4	imgui.h	/^    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }$/;"	f	struct:ImVec4
ImVec4	imgui.h	/^struct ImVec4$/;"	s
ImVector	imgui.h	/^    ImVector()                  { Size = Capacity = 0; Data = NULL; }$/;"	f	class:ImVector
ImVector	imgui.h	/^class ImVector$/;"	c
ImWchar	imgui.h	/^typedef unsigned short ImWchar;     \/\/ character for keyboard input\/display$/;"	t
Image	imgui.cpp	/^void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)$/;"	f	class:ImGui
ImageButton	imgui.cpp	/^bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)$/;"	f	class:ImGui
ImeSetInputScreenPosFn	imgui.h	/^    void        (*ImeSetInputScreenPosFn)(int x, int y);$/;"	m	struct:ImGuiIO
ImeSetInputScreenPosFn_DefaultImpl	imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)$/;"	f	file:
ImeSetInputScreenPosFn_DefaultImpl	imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}$/;"	f	file:
ImeWindowHandle	imgui.h	/^    void*       ImeWindowHandle;            \/\/ (Windows) Set this to your HWND to get automatic IME cursor positioning.$/;"	m	struct:ImGuiIO
Indent	imgui.cpp	/^void ImGui::Indent()$/;"	f	class:ImGui
IndentSpacing	imgui.h	/^    float       IndentSpacing;              \/\/ Horizontal indentation when e.g. entering a tree node$/;"	m	struct:ImGuiStyle
IndentX	imgui_internal.h	/^    float                   IndentX;                \/\/ Indentation \/ start position from left of window (increased by TreePush\/TreePop, etc.)$/;"	m	struct:ImGuiDrawContext
IndexLookup	imgui.h	/^    ImVector<int>               IndexLookup;        \/\/ Sparse. Index glyphs by Unicode code-point.$/;"	m	struct:ImFont
IndexXAdvance	imgui.h	/^    ImVector<float>             IndexXAdvance;      \/\/ Sparse. Glyphs->XAdvance directly indexable (more cache-friendly that reading from Glyphs, for CalcTextSize functions which are often bottleneck in large UI)$/;"	m	struct:ImFont
IniFilename	imgui.h	/^    const char*   IniFilename;              \/\/ = "imgui.ini"        \/\/ Path to .ini file. NULL to disable .ini saving.$/;"	m	struct:ImGuiIO
IniSavingRate	imgui.h	/^    float         IniSavingRate;            \/\/ = 5.0f               \/\/ Maximum time between saving positions\/sizes to .ini file, in seconds.$/;"	m	struct:ImGuiIO
InitMesh	func.h	/^void InitMesh() {$/;"	f
InitialText	imgui_internal.h	/^    ImVector<char>      InitialText;                \/\/ backup of end-user buffer at the time of focus (in UTF-8, unaltered)$/;"	m	struct:ImGuiTextEditState
Initialized	imgui_internal.h	/^    bool                    Initialized;$/;"	m	struct:ImGuiState
InputBuf	imgui.h	/^    char                InputBuf[256];$/;"	m	struct:ImGuiTextFilter
InputBuf	imgui_demo.cpp	/^    char                  InputBuf[256];$/;"	m	struct:ExampleAppConsole	file:
InputCharacters	imgui.h	/^    ImWchar     InputCharacters[16+1];      \/\/ List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.$/;"	m	struct:ImGuiIO
InputFloat	imgui.cpp	/^bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputFloat2	imgui.cpp	/^bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputFloat3	imgui.cpp	/^bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputFloat4	imgui.cpp	/^bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputFloatN	imgui.cpp	/^bool ImGui::InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputInt	imgui.cpp	/^bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputInt2	imgui.cpp	/^bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputInt3	imgui.cpp	/^bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputInt4	imgui.cpp	/^bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputIntN	imgui.cpp	/^bool ImGui::InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputScalarAsWidgetReplacement	imgui.cpp	/^bool ImGui::InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)$/;"	f	class:ImGui
InputScalarEx	imgui.cpp	/^bool ImGui::InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui
InputText	imgui.cpp	/^bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui
InputTextCalcTextLenAndLineCount	imgui.cpp	/^static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)$/;"	f	file:
InputTextCalcTextSizeW	imgui.cpp	/^static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)$/;"	f	file:
InputTextEx	imgui.cpp	/^bool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui
InputTextFilterCharacter	imgui.cpp	/^static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	file:
InputTextMultiline	imgui.cpp	/^bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui
InputTextPasswordFont	imgui_internal.h	/^    ImFont                  InputTextPasswordFont;$/;"	m	struct:ImGuiState
InputTextState	imgui_internal.h	/^    ImGuiTextEditState      InputTextState;$/;"	m	struct:ImGuiState
InsertChars	imgui.cpp	/^void ImGuiTextEditCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)$/;"	f	class:ImGuiTextEditCallbackData
InvisibleButton	imgui.cpp	/^bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)$/;"	f	class:ImGui
IsActive	imgui.h	/^    bool                IsActive() const { return !Filters.empty(); }$/;"	f	struct:ImGuiTextFilter
IsAnyItemActive	imgui.cpp	/^bool ImGui::IsAnyItemActive()$/;"	f	class:ImGui
IsAnyItemHovered	imgui.cpp	/^bool ImGui::IsAnyItemHovered()$/;"	f	class:ImGui
IsClipped	imgui.h	/^    static inline bool      IsClipped(const ImVec2& size) { return !IsRectVisible(size); }     \/\/ OBSOLETE 1.38+$/;"	f	namespace:ImGui
IsClippedEx	imgui.cpp	/^bool ImGui::IsClippedEx(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)$/;"	f	class:ImGui
IsHovered	imgui.cpp	/^bool ImGui::IsHovered(const ImRect& bb, ImGuiID id, bool flatten_childs)$/;"	f	class:ImGui
IsItemActive	imgui.cpp	/^bool ImGui::IsItemActive()$/;"	f	class:ImGui
IsItemHovered	imgui.cpp	/^bool ImGui::IsItemHovered()$/;"	f	class:ImGui
IsItemHoveredRect	imgui.cpp	/^bool ImGui::IsItemHoveredRect()$/;"	f	class:ImGui
IsItemVisible	imgui.cpp	/^bool ImGui::IsItemVisible()$/;"	f	class:ImGui
IsKeyDown	imgui.cpp	/^bool ImGui::IsKeyDown(int key_index)$/;"	f	class:ImGui
IsKeyPressed	imgui.cpp	/^bool ImGui::IsKeyPressed(int key_index, bool repeat)$/;"	f	class:ImGui
IsKeyPressedMap	imgui.cpp	/^static bool IsKeyPressedMap(ImGuiKey key, bool repeat)$/;"	f	file:
IsKeyReleased	imgui.cpp	/^bool ImGui::IsKeyReleased(int key_index)$/;"	f	class:ImGui
IsLoaded	imgui.h	/^    bool                        IsLoaded() const                        { return ContainerAtlas != NULL; }$/;"	f	struct:ImFont
IsMouseClicked	imgui.cpp	/^bool ImGui::IsMouseClicked(int button, bool repeat)$/;"	f	class:ImGui
IsMouseDoubleClicked	imgui.cpp	/^bool ImGui::IsMouseDoubleClicked(int button)$/;"	f	class:ImGui
IsMouseDown	imgui.cpp	/^bool ImGui::IsMouseDown(int button)$/;"	f	class:ImGui
IsMouseDragging	imgui.cpp	/^bool ImGui::IsMouseDragging(int button, float lock_threshold)$/;"	f	class:ImGui
IsMouseHoveringAnyWindow	imgui.cpp	/^bool ImGui::IsMouseHoveringAnyWindow()$/;"	f	class:ImGui
IsMouseHoveringBox	imgui.h	/^    static inline bool      IsMouseHoveringBox(const ImVec2& rect_min, const ImVec2& rect_max) { return IsMouseHoveringRect(rect_min, rect_max); }  \/\/ OBSOLETE 1.36+$/;"	f	namespace:ImGui
IsMouseHoveringRect	imgui.cpp	/^bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)$/;"	f	class:ImGui
IsMouseHoveringWindow	imgui.cpp	/^bool ImGui::IsMouseHoveringWindow()$/;"	f	class:ImGui
IsMouseReleased	imgui.cpp	/^bool ImGui::IsMouseReleased(int button)$/;"	f	class:ImGui
IsPopupOpen	imgui.cpp	/^static bool IsPopupOpen(ImGuiID id)$/;"	f	file:
IsPosHoveringAnyWindow	imgui.cpp	/^bool ImGui::IsPosHoveringAnyWindow(const ImVec2& pos)$/;"	f	class:ImGui
IsRectClipped	imgui.h	/^    static inline bool      IsRectClipped(const ImVec2& size) { return !IsRectVisible(size); } \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui
IsRectVisible	imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& size)$/;"	f	class:ImGui
IsRootWindowFocused	imgui.cpp	/^bool ImGui::IsRootWindowFocused()$/;"	f	class:ImGui
IsRootWindowOrAnyChildFocused	imgui.cpp	/^bool ImGui::IsRootWindowOrAnyChildFocused()$/;"	f	class:ImGui
IsWindowCollapsed	imgui.cpp	/^bool ImGui::IsWindowCollapsed()$/;"	f	class:ImGui
IsWindowContentHoverable	imgui.cpp	/^static inline bool IsWindowContentHoverable(ImGuiWindow* window)$/;"	f	file:
IsWindowFocused	imgui.cpp	/^bool ImGui::IsWindowFocused()$/;"	f	class:ImGui
IsWindowHovered	imgui.cpp	/^bool ImGui::IsWindowHovered()$/;"	f	class:ImGui
ItemAdd	imgui.cpp	/^bool ImGui::ItemAdd(const ImRect& bb, const ImGuiID* id)$/;"	f	class:ImGui
ItemInnerSpacing	imgui.h	/^    ImVec2      ItemInnerSpacing;           \/\/ Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)$/;"	m	struct:ImGuiStyle
ItemSize	imgui.cpp	/^void ImGui::ItemSize(const ImRect& bb, float text_offset_y)$/;"	f	class:ImGui
ItemSize	imgui.cpp	/^void ImGui::ItemSize(const ImVec2& size, float text_offset_y)$/;"	f	class:ImGui
ItemSpacing	imgui.h	/^    ImVec2      ItemSpacing;                \/\/ Horizontal and vertical spacing between widgets\/lines$/;"	m	struct:ImGuiStyle
ItemWidth	imgui_internal.h	/^    float                   ItemWidth;              \/\/ == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window$/;"	m	struct:ImGuiDrawContext
ItemWidthDefault	imgui_internal.h	/^    float                   ItemWidthDefault;$/;"	m	struct:ImGuiWindow
ItemWidthStack	imgui_internal.h	/^    ImVector<float>         ItemWidthStack;$/;"	m	struct:ImGuiDrawContext
Items	imgui_demo.cpp	/^    ImVector<char*>       Items;$/;"	m	struct:ExampleAppConsole	file:
ItemsCount	imgui.h	/^    int     ItemsCount, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper
ItemsHeight	imgui.h	/^    float   ItemsHeight;$/;"	m	struct:ImGuiListClipper
Items_ArrayGetter	imgui.cpp	/^static bool Items_ArrayGetter(void* data, int idx, const char** out_text)$/;"	f	file:
Items_SingleStringGetter	imgui.cpp	/^static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)$/;"	f	file:
KeepAliveID	imgui.cpp	/^void ImGui::KeepAliveID(ImGuiID id)$/;"	f	class:ImGui
KeyAlt	imgui.h	/^    bool        KeyAlt;                     \/\/ Keyboard modifier pressed: Alt$/;"	m	struct:ImGuiIO
KeyCtrl	imgui.h	/^    bool        KeyCtrl;                    \/\/ Keyboard modifier pressed: Control$/;"	m	struct:ImGuiIO
KeyMap	imgui.h	/^    int           KeyMap[ImGuiKey_COUNT];   \/\/ <unset>              \/\/ Map of indices into the KeysDown[512] entries array$/;"	m	struct:ImGuiIO
KeyRepeatDelay	imgui.h	/^    float         KeyRepeatDelay;           \/\/ = 0.250f             \/\/ When holding a key\/button, time before it starts repeating, in seconds. (for actions where 'repeat' is active)$/;"	m	struct:ImGuiIO
KeyRepeatRate	imgui.h	/^    float         KeyRepeatRate;            \/\/ = 0.020f             \/\/ When holding a key\/button, rate at which it repeats, in seconds.$/;"	m	struct:ImGuiIO
KeyShift	imgui.h	/^    bool        KeyShift;                   \/\/ Keyboard modifier pressed: Shift$/;"	m	struct:ImGuiIO
KeySuper	imgui.h	/^    bool        KeySuper;                   \/\/ Keyboard modifier pressed: Cmd\/Super\/Windows$/;"	m	struct:ImGuiIO
KeysDown	imgui.h	/^    bool        KeysDown[512];              \/\/ Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)$/;"	m	struct:ImGuiIO
KeysDownDuration	imgui.h	/^    float       KeysDownDuration[512];      \/\/ Duration the keyboard key has been down (0.0f == just pressed)$/;"	m	struct:ImGuiIO
KeysDownDurationPrev	imgui.h	/^    float       KeysDownDurationPrev[512];  \/\/ Previous duration the key has been down$/;"	m	struct:ImGuiIO
LIBS	Makefile	/^LIBS=`sdl2-config --cflags --libs` -lGLEW -lGL -lGLU -l glut -lm$/;"	m
LabelText	imgui.cpp	/^void ImGui::LabelText(const char* label, const char* fmt, ...)$/;"	f	class:ImGui
LabelTextV	imgui.cpp	/^void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)$/;"	f	class:ImGui
LastFrameActive	imgui_internal.h	/^    int                     LastFrameActive;$/;"	m	struct:ImGuiWindow
LastItemHoveredAndUsable	imgui_internal.h	/^    bool                    LastItemHoveredAndUsable;  \/\/ Item rectangle is hovered, and its window is currently interactable with (not blocked by a popup preventing access to the window)$/;"	m	struct:ImGuiDrawContext
LastItemHoveredRect	imgui_internal.h	/^    bool                    LastItemHoveredRect;       \/\/ Item rectangle is hovered, but its window may or not be currently interactable with (might be blocked by a popup preventing access to the window)$/;"	m	struct:ImGuiDrawContext
LastItemID	imgui_internal.h	/^    ImGuiID                 LastItemID;$/;"	m	struct:ImGuiDrawContext
LastItemRect	imgui_internal.h	/^    ImRect                  LastItemRect;$/;"	m	struct:ImGuiDrawContext
LayoutType	imgui_internal.h	/^    ImGuiLayoutType         LayoutType;$/;"	m	struct:ImGuiDrawContext
LineOffsets	imgui_demo.cpp	/^    ImVector<int>       LineOffsets;        \/\/ Index to lines offset$/;"	m	struct:ExampleAppLog	file:
ListBox	imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui
ListBox	imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, const char** items, int items_count, int height_items)$/;"	f	class:ImGui
ListBoxFooter	imgui.cpp	/^void ImGui::ListBoxFooter()$/;"	f	class:ImGui
ListBoxHeader	imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui
ListBoxHeader	imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)$/;"	f	class:ImGui
LoadSettings	imgui.cpp	/^static void LoadSettings()$/;"	f	file:
LogAutoExpandMaxDepth	imgui_internal.h	/^    int                     LogAutoExpandMaxDepth;$/;"	m	struct:ImGuiState
LogButtons	imgui.cpp	/^void ImGui::LogButtons()$/;"	f	class:ImGui
LogClipboard	imgui_internal.h	/^    ImGuiTextBuffer*        LogClipboard;                       \/\/ Else log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.$/;"	m	struct:ImGuiState
LogEnabled	imgui_internal.h	/^    bool                    LogEnabled;$/;"	m	struct:ImGuiState
LogFile	imgui_internal.h	/^    FILE*                   LogFile;                            \/\/ If != NULL log to stdout\/ file$/;"	m	struct:ImGuiState
LogFilename	imgui.h	/^    const char*   LogFilename;              \/\/ = "imgui_log.txt"    \/\/ Path to .log file (default parameter to ImGui::LogToFile when no file is specified).$/;"	m	struct:ImGuiIO
LogFinish	imgui.cpp	/^void ImGui::LogFinish()$/;"	f	class:ImGui
LogLinePosY	imgui_internal.h	/^    float                   LogLinePosY;$/;"	m	struct:ImGuiDrawContext
LogRenderedText	imgui.cpp	/^static void LogRenderedText(const ImVec2& ref_pos, const char* text, const char* text_end)$/;"	f	file:
LogStartDepth	imgui_internal.h	/^    int                     LogStartDepth;$/;"	m	struct:ImGuiState
LogText	imgui.cpp	/^void ImGui::LogText(const char* fmt, ...)$/;"	f	class:ImGui
LogToClipboard	imgui.cpp	/^void ImGui::LogToClipboard(int max_depth)$/;"	f	class:ImGui
LogToFile	imgui.cpp	/^void ImGui::LogToFile(int max_depth, const char* filename)$/;"	f	class:ImGui
LogToTTY	imgui.cpp	/^void ImGui::LogToTTY(int max_depth)$/;"	f	class:ImGui
LowerBound	imgui.cpp	/^static ImVector<ImGuiStorage::Pair>::iterator LowerBound(ImVector<ImGuiStorage::Pair>& data, ImU32 key)$/;"	f	file:
MarkSettingsDirty	imgui.cpp	/^static void MarkSettingsDirty()$/;"	f	file:
Max	imgui_internal.h	/^    ImVec2      Max;    \/\/ Lower-right$/;"	m	struct:ImRect
MemAlloc	imgui.cpp	/^void* ImGui::MemAlloc(size_t sz)$/;"	f	class:ImGui
MemAllocFn	imgui.h	/^    void*       (*MemAllocFn)(size_t sz);$/;"	m	struct:ImGuiIO
MemFree	imgui.cpp	/^void ImGui::MemFree(void* ptr)$/;"	f	class:ImGui
MemFreeFn	imgui.h	/^    void        (*MemFreeFn)(void* ptr);$/;"	m	struct:ImGuiIO
MenuBarAppending	imgui_internal.h	/^    bool                    MenuBarAppending;$/;"	m	struct:ImGuiDrawContext
MenuBarHeight	imgui_internal.h	/^    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }$/;"	f	struct:ImGuiWindow
MenuBarOffsetX	imgui_internal.h	/^    float                   MenuBarOffsetX;$/;"	m	struct:ImGuiDrawContext
MenuBarRect	imgui_internal.h	/^    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }$/;"	f	struct:ImGuiWindow
MenuColumns	imgui_internal.h	/^    ImGuiSimpleColumns      MenuColumns;                        \/\/ Simplified columns storage for menu items$/;"	m	struct:ImGuiWindow
MenuItem	imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)$/;"	f	class:ImGui
MenuItem	imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)$/;"	f	class:ImGui
MergeGlyphCenterV	imgui.h	/^    bool            MergeGlyphCenterV;          \/\/ false    \/\/ When merging (multiple ImFontInput for one ImFont), vertically center new glyphs instead of aligning their baseline$/;"	m	struct:ImFontConfig
MergeMode	imgui.h	/^    bool            MergeMode;                  \/\/ false    \/\/ Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs).$/;"	m	struct:ImFontConfig
MetricsActiveWindows	imgui.h	/^    int         MetricsActiveWindows;       \/\/ Number of visible windows (exclude child windows)$/;"	m	struct:ImGuiIO
MetricsAllocs	imgui.h	/^    int         MetricsAllocs;              \/\/ Number of active memory allocations$/;"	m	struct:ImGuiIO
MetricsRenderIndices	imgui.h	/^    int         MetricsRenderIndices;       \/\/ Indices output during last call to Render() = number of triangles * 3$/;"	m	struct:ImGuiIO
MetricsRenderVertices	imgui.h	/^    int         MetricsRenderVertices;      \/\/ Vertices output during last call to Render()$/;"	m	struct:ImGuiIO
Min	imgui_internal.h	/^    ImVec2      Min;    \/\/ Upper-left$/;"	m	struct:ImRect
ModalWindowDarkeningRatio	imgui_internal.h	/^    float                   ModalWindowDarkeningRatio;$/;"	m	struct:ImGuiState
MouseClicked	imgui.h	/^    bool        MouseClicked[5];            \/\/ Mouse button went from !Down to Down$/;"	m	struct:ImGuiIO
MouseClickedPos	imgui.h	/^    ImVec2      MouseClickedPos[5];         \/\/ Position at time of clicking$/;"	m	struct:ImGuiIO
MouseClickedTime	imgui.h	/^    float       MouseClickedTime[5];        \/\/ Time of last click (used to figure out double-click)$/;"	m	struct:ImGuiIO
MouseCursor	imgui_internal.h	/^    ImGuiMouseCursor        MouseCursor;$/;"	m	struct:ImGuiState
MouseCursorData	imgui_internal.h	/^    ImGuiMouseCursorData    MouseCursorData[ImGuiMouseCursor_Count_];$/;"	m	struct:ImGuiState
MouseDelta	imgui.h	/^    ImVec2      MouseDelta;                 \/\/ Mouse delta. Note that this is zero if either current or previous position are negative to allow mouse enabling\/disabling.$/;"	m	struct:ImGuiIO
MouseDoubleClickMaxDist	imgui.h	/^    float         MouseDoubleClickMaxDist;  \/\/ = 6.0f               \/\/ Distance threshold to stay in to validate a double-click, in pixels.$/;"	m	struct:ImGuiIO
MouseDoubleClickTime	imgui.h	/^    float         MouseDoubleClickTime;     \/\/ = 0.30f              \/\/ Time for a double-click, in seconds.$/;"	m	struct:ImGuiIO
MouseDoubleClicked	imgui.h	/^    bool        MouseDoubleClicked[5];      \/\/ Has mouse button been double-clicked?$/;"	m	struct:ImGuiIO
MouseDown	imgui.h	/^    bool        MouseDown[5];               \/\/ Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.$/;"	m	struct:ImGuiIO
MouseDownDuration	imgui.h	/^    float       MouseDownDuration[5];       \/\/ Duration the mouse button has been down (0.0f == just clicked)$/;"	m	struct:ImGuiIO
MouseDownDurationPrev	imgui.h	/^    float       MouseDownDurationPrev[5];   \/\/ Previous time the mouse button has been down$/;"	m	struct:ImGuiIO
MouseDownOwned	imgui.h	/^    bool        MouseDownOwned[5];          \/\/ Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.$/;"	m	struct:ImGuiIO
MouseDragMaxDistanceSqr	imgui.h	/^    float       MouseDragMaxDistanceSqr[5]; \/\/ Squared maximum distance of how much mouse has traveled from the click point$/;"	m	struct:ImGuiIO
MouseDragThreshold	imgui.h	/^    float         MouseDragThreshold;       \/\/ = 6.0f               \/\/ Distance threshold before considering we are dragging$/;"	m	struct:ImGuiIO
MouseDrawCursor	imgui.h	/^    bool        MouseDrawCursor;            \/\/ Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).$/;"	m	struct:ImGuiIO
MousePos	imgui.h	/^    ImVec2      MousePos;                   \/\/ Mouse position, in pixels (set to -1,-1 if no mouse \/ on another screen, etc.)$/;"	m	struct:ImGuiIO
MousePosOnOpen	imgui_internal.h	/^    ImVec2          MousePosOnOpen; \/\/ Copy of mouse position at the time of opening popup$/;"	m	struct:ImGuiPopupRef
MousePosPrev	imgui.h	/^    ImVec2      MousePosPrev;               \/\/ Previous mouse position$/;"	m	struct:ImGuiIO
MouseReleased	imgui.h	/^    bool        MouseReleased[5];           \/\/ Mouse button went from Down to !Down$/;"	m	struct:ImGuiIO
MouseToCamera	app_state_and_events.h	/^    bool MouseToCamera;$/;"	m	class:AppStateAndEvents
MouseWheel	imgui.h	/^    float       MouseWheel;                 \/\/ Mouse wheel: 1 unit scrolls about 5 lines text.$/;"	m	struct:ImGuiIO
MoveID	imgui_internal.h	/^    ImGuiID                 MoveID;                             \/\/ == window->GetID("#MOVE")$/;"	m	struct:ImGuiWindow
MovedWindow	imgui_internal.h	/^    ImGuiWindow*            MovedWindow;                        \/\/ Track the child window we clicked on to move a window. Pointer is only valid if ActiveID is the "#MOVE" identifier of a window.$/;"	m	struct:ImGuiState
MultiSelectUsesSuperKey	imgui.h	/^    bool          MultiSelectUsesSuperKey;  \/\/ = defined(__APPLE__) \/\/ OS X style: Multi-selection in lists uses Cmd\/Super instead of Ctrl [unused yet]$/;"	m	struct:ImGuiIO
Name	imgui.h	/^    char            Name[32];                               \/\/ Name (strictly for debugging)$/;"	m	struct:ImFontConfig
Name	imgui_internal.h	/^    char*                   Name;$/;"	m	struct:ImGuiWindow
Name	imgui_internal.h	/^    char*       Name;$/;"	m	struct:ImGuiIniData
NewFrame	imgui.cpp	/^void ImGui::NewFrame()$/;"	f	class:ImGui
NextColumn	imgui.cpp	/^void ImGui::NextColumn()$/;"	f	class:ImGui
NextWidth	imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns
NextWidths	imgui_internal.h	/^    float       Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns
OBJ	Makefile	/^OBJ=sdl_main.o render2d.o imgui.o imgui_impl_sdl.o imgui_draw.o event.o ui.o app_state_and_events.o$/;"	m
OBJECTS_COUNT	palace.h	4;"	d
OBJECTS_COUNT	untitled.h	4;"	d
OFFSETOF	imgui_impl_sdl.cpp	61;"	d	file:
OFFSETOF	imgui_impl_sdl.cpp	88;"	d	file:
OffsetNorm	imgui_internal.h	/^    float       OffsetNorm;     \/\/ Column start offset, normalized 0.0 (far left) -> 1.0 (far right)$/;"	m	struct:ImGuiColumnData
OnKeyPressed	imgui.cpp	/^void ImGuiTextEditState::OnKeyPressed(int key)$/;"	f	class:ImGuiTextEditState
OpenNextNode	imgui.h	/^    static inline void      OpenNextNode(bool open) { ImGui::SetNextTreeNodeOpened(open, 0); } \/\/ OBSOLETE 1.34+$/;"	f	namespace:ImGui
OpenPopup	imgui.cpp	/^void ImGui::OpenPopup(const char* str_id)$/;"	f	class:ImGui
OpenPopupEx	imgui.cpp	/^void ImGui::OpenPopupEx(const char* str_id, bool reopen_existing)$/;"	f	class:ImGui
OpenedPopupStack	imgui_internal.h	/^    ImVector<ImGuiPopupRef> OpenedPopupStack;                   \/\/ Which popups are open (persistent)$/;"	m	struct:ImGuiState
OsImePosRequest	imgui_internal.h	/^    ImVec2                  OsImePosRequest, OsImePosSet;       \/\/ Cursor position request & last passed to the OS Input Method Editor$/;"	m	struct:ImGuiState
OsImePosSet	imgui_internal.h	/^    ImVec2                  OsImePosRequest, OsImePosSet;       \/\/ Cursor position request & last passed to the OS Input Method Editor$/;"	m	struct:ImGuiState
Overlaps	imgui_internal.h	/^    bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }$/;"	f	struct:ImRect
OverlayDrawList	imgui_internal.h	/^    ImDrawList              OverlayDrawList;                    \/\/ Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays$/;"	m	struct:ImGuiState
OversampleH	imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig
OversampleV	imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig
PLANE	untitled.h	9;"	d
Pair	imgui.h	/^        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }$/;"	f	struct:ImGuiStorage::Pair
Pair	imgui.h	/^        Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }$/;"	f	struct:ImGuiStorage::Pair
Pair	imgui.h	/^        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }$/;"	f	struct:ImGuiStorage::Pair
Pair	imgui.h	/^    struct Pair$/;"	s	struct:ImGuiStorage
ParentMenuSet	imgui_internal.h	/^    ImGuiID         ParentMenuSet;  \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef
ParentWindow	imgui_internal.h	/^    ImGuiWindow*    ParentWindow;   \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef
ParseFormatPrecision	imgui.cpp	/^int ImGui::ParseFormatPrecision(const char* fmt, int default_precision)$/;"	f	class:ImGui
PassFilter	imgui.cpp	/^bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const$/;"	f	class:ImGuiTextFilter
PathArcTo	imgui_draw.cpp	/^void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float amin, float amax, int num_segments)$/;"	f	class:ImDrawList
PathArcToFast	imgui_draw.cpp	/^void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int amin, int amax)$/;"	f	class:ImDrawList
PathBezierCurveTo	imgui_draw.cpp	/^void ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)$/;"	f	class:ImDrawList
PathBezierToCasteljau	imgui_draw.cpp	/^static void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)$/;"	f	file:
PathClear	imgui.h	/^    inline    void  PathClear()                                                 { _Path.resize(0); }$/;"	f	struct:ImDrawList
PathFill	imgui.h	/^    inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }$/;"	f	struct:ImDrawList
PathLineTo	imgui.h	/^    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }$/;"	f	struct:ImDrawList
PathLineToMergeDuplicate	imgui.h	/^    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }$/;"	f	struct:ImDrawList
PathRect	imgui_draw.cpp	/^void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)$/;"	f	class:ImDrawList
PathStroke	imgui.h	/^    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }$/;"	f	struct:ImDrawList
PixelSnapH	imgui.h	/^    bool            PixelSnapH;                 \/\/ false    \/\/ Align every character to pixel boundary (if enabled, set OversampleH\/V to 1)$/;"	m	struct:ImFontConfig
PlotEx	imgui.cpp	/^void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui
PlotHistogram	imgui.cpp	/^void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui
PlotHistogram	imgui.cpp	/^void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui
PlotLines	imgui.cpp	/^void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui
PlotLines	imgui.cpp	/^void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui
Plot_ArrayGetter	imgui.cpp	/^static float Plot_ArrayGetter(void* data, int idx)$/;"	f	file:
PopAllowKeyboardFocus	imgui.cpp	/^void ImGui::PopAllowKeyboardFocus()$/;"	f	class:ImGui
PopButtonRepeat	imgui.cpp	/^void ImGui::PopButtonRepeat()$/;"	f	class:ImGui
PopClipRect	imgui.cpp	/^void ImGui::PopClipRect()$/;"	f	class:ImGui
PopClipRect	imgui_draw.cpp	/^void ImDrawList::PopClipRect()$/;"	f	class:ImDrawList
PopFont	imgui.cpp	/^void  ImGui::PopFont()$/;"	f	class:ImGui
PopID	imgui.cpp	/^void ImGui::PopID()$/;"	f	class:ImGui
PopItemWidth	imgui.cpp	/^void ImGui::PopItemWidth()$/;"	f	class:ImGui
PopStyleColor	imgui.cpp	/^void ImGui::PopStyleColor(int count)$/;"	f	class:ImGui
PopStyleVar	imgui.cpp	/^void ImGui::PopStyleVar(int count)$/;"	f	class:ImGui
PopTextWrapPos	imgui.cpp	/^void ImGui::PopTextWrapPos()$/;"	f	class:ImGui
PopTextureID	imgui_draw.cpp	/^void ImDrawList::PopTextureID()$/;"	f	class:ImDrawList
PopupID	imgui_internal.h	/^    ImGuiID                 PopupID;                            \/\/ ID in the popup stack when this window is used as a popup\/menu (because we use generic Name\/ID for recycling)$/;"	m	struct:ImGuiWindow
PopupID	imgui_internal.h	/^    ImGuiID         PopupID;        \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef
Pos	imgui_internal.h	/^    ImVec2                  Pos;                                \/\/ Position rounded-up to nearest pixel$/;"	m	struct:ImGuiWindow
Pos	imgui_internal.h	/^    ImVec2      Pos;$/;"	m	struct:ImGuiIniData
Pos	imgui_internal.h	/^    float       Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns
PosFloat	imgui_internal.h	/^    ImVec2                  PosFloat;$/;"	m	struct:ImGuiWindow
PrevLineHeight	imgui_internal.h	/^    float                   PrevLineHeight;$/;"	m	struct:ImGuiDrawContext
PrevLineTextBaseOffset	imgui_internal.h	/^    float                   PrevLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext
PreviousValue	imgui_internal.h	/^    ImVec2          PreviousValue;$/;"	m	struct:ImGuiStyleMod
PreviousValue	imgui_internal.h	/^    ImVec4      PreviousValue;$/;"	m	struct:ImGuiColMod
PrimQuadUV	imgui_draw.cpp	/^void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)$/;"	f	class:ImDrawList
PrimRect	imgui_draw.cpp	/^void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList
PrimRectUV	imgui_draw.cpp	/^void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)$/;"	f	class:ImDrawList
PrimReserve	imgui_draw.cpp	/^void ImDrawList::PrimReserve(int idx_count, int vtx_count)$/;"	f	class:ImDrawList
PrimVtx	imgui.h	/^    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }$/;"	f	struct:ImDrawList
PrimWriteIdx	imgui.h	/^    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }$/;"	f	struct:ImDrawList
PrimWriteVtx	imgui.h	/^    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }$/;"	f	struct:ImDrawList
PrivateClipboard	imgui_internal.h	/^    char*                   PrivateClipboard;                   \/\/ If no custom clipboard handler is defined$/;"	m	struct:ImGuiState
ProgressBar	imgui.cpp	/^void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)$/;"	f	class:ImGui
PushAllowKeyboardFocus	imgui.cpp	/^void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)$/;"	f	class:ImGui
PushButtonRepeat	imgui.cpp	/^void ImGui::PushButtonRepeat(bool repeat)$/;"	f	class:ImGui
PushClipRect	imgui.cpp	/^void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_existing_clip_rect)$/;"	f	class:ImGui
PushClipRect	imgui_draw.cpp	/^void ImDrawList::PushClipRect(const ImVec4& clip_rect)$/;"	f	class:ImDrawList
PushClipRectFullScreen	imgui_draw.cpp	/^void ImDrawList::PushClipRectFullScreen()$/;"	f	class:ImDrawList
PushColumnClipRect	imgui.cpp	/^static void PushColumnClipRect(int column_index)$/;"	f	file:
PushFont	imgui.cpp	/^void ImGui::PushFont(ImFont* font)$/;"	f	class:ImGui
PushID	imgui.cpp	/^void ImGui::PushID(const char* str_id)$/;"	f	class:ImGui
PushID	imgui.cpp	/^void ImGui::PushID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui
PushID	imgui.cpp	/^void ImGui::PushID(const void* ptr_id)$/;"	f	class:ImGui
PushID	imgui.cpp	/^void ImGui::PushID(int int_id)$/;"	f	class:ImGui
PushItemWidth	imgui.cpp	/^void ImGui::PushItemWidth(float item_width)$/;"	f	class:ImGui
PushMultiItemsWidths	imgui.cpp	/^static void PushMultiItemsWidths(int components, float w_full)$/;"	f	file:
PushStyleColor	imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)$/;"	f	class:ImGui
PushStyleVar	imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)$/;"	f	class:ImGui
PushStyleVar	imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)$/;"	f	class:ImGui
PushTextWrapPos	imgui.cpp	/^void ImGui::PushTextWrapPos(float wrap_pos_x)$/;"	f	class:ImGui
PushTextureID	imgui_draw.cpp	/^void ImDrawList::PushTextureID(const ImTextureID& texture_id)$/;"	f	class:ImDrawList
RENDER_2D	render2d.h	2;"	d
RENDER_3D	render3d.h	2;"	d
RadioButton	imgui.cpp	/^bool ImGui::RadioButton(const char* label, bool active)$/;"	f	class:ImGui
RadioButton	imgui.cpp	/^bool ImGui::RadioButton(const char* label, int* v, int v_button)$/;"	f	class:ImGui
ReadOnly	imgui.h	/^    bool                ReadOnly;       \/\/ Read-only mode                       \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData
Rect	imgui_internal.h	/^    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }$/;"	f	struct:ImGuiWindow
Reduce	imgui_internal.h	/^    void        Reduce(const ImVec2& amount)    { Min.x += amount.x; Min.y += amount.y; Max.x -= amount.x; Max.y -= amount.y; }$/;"	f	struct:ImRect
RefFrame	imgui.h	/^    mutable int RefFrame;$/;"	m	struct:ImGuiOnceUponAFrame
Render	imgui.cpp	/^void ImGui::Render()$/;"	f	class:ImGui
RenderCheckMark	imgui.cpp	/^void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col)$/;"	f	class:ImGui
RenderCollapseTriangle	imgui.cpp	/^void ImGui::RenderCollapseTriangle(ImVec2 p_min, bool opened, float scale, bool shadow)$/;"	f	class:ImGui
RenderCustomTexData	imgui_draw.cpp	/^void ImFontAtlas::RenderCustomTexData(int pass, void* p_rects)$/;"	f	class:ImFontAtlas
RenderDrawData	imgui_internal.h	/^    ImDrawData              RenderDrawData;                     \/\/ Main ImDrawData instance to pass render information to the user$/;"	m	struct:ImGuiState
RenderDrawLists	imgui_internal.h	/^    ImVector<ImDrawList*>   RenderDrawLists[3];$/;"	m	struct:ImGuiState
RenderDrawListsFn	imgui.h	/^    void        (*RenderDrawListsFn)(ImDrawData* data);$/;"	m	struct:ImGuiIO
RenderFrame	imgui.cpp	/^void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)$/;"	f	class:ImGui
RenderText	imgui.cpp	/^void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)$/;"	f	class:ImGui
RenderText	imgui_draw.cpp	/^void ImFont::RenderText(float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, ImDrawList* draw_list, float wrap_width, bool cpu_fine_clip) const$/;"	f	class:ImFont
RenderTextClipped	imgui.cpp	/^void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, ImGuiAlign align, const ImVec2* clip_min, const ImVec2* clip_max)$/;"	f	class:ImGui
RenderTextWrapped	imgui.cpp	/^void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)$/;"	f	class:ImGui
ResetMouseDragDelta	imgui.cpp	/^void ImGui::ResetMouseDragDelta(int button)$/;"	f	class:ImGui
Resize	render2d.cpp	/^void Resize(int width, int height) {$/;"	f
Resize	render3d.cpp	/^void Resize(int width, int height) {$/;"	f
RootNonPopupWindow	imgui_internal.h	/^    ImGuiWindow*            RootNonPopupWindow;$/;"	m	struct:ImGuiWindow
RootWindow	imgui_internal.h	/^    ImGuiWindow*            RootWindow;$/;"	m	struct:ImGuiWindow
Round	imgui_internal.h	/^    void        Round()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }$/;"	f	struct:ImRect
RoundScalar	imgui.cpp	/^float ImGui::RoundScalar(float value, int decimal_precision)$/;"	f	class:ImGui
SDL_Event	imgui_impl_sdl.h	/^typedef union SDL_Event SDL_Event;$/;"	t	typeref:union:SDL_Event
SRC	Makefile	/^SRC=sdl_main.c render2d.c imgui.cpp imgui_impl_sdl.cpp imgui_draw.cpp event.cpp ui.cpp app_state_and_events.cpp$/;"	m
STBRP_ASSERT	imgui_draw.cpp	71;"	d	file:
STBRP_ASSERT	stb_rect_pack.h	198;"	d
STBRP_DEF	stb_rect_pack.h	59;"	d
STBRP_DEF	stb_rect_pack.h	61;"	d
STBRP_HEURISTIC_Skyline_BF_sortHeight	stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_BF_sortHeight$/;"	e	enum:__anon22
STBRP_HEURISTIC_Skyline_BL_sortHeight	stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,$/;"	e	enum:__anon22
STBRP_HEURISTIC_Skyline_default	stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_default=0,$/;"	e	enum:__anon22
STBRP_SORT	stb_rect_pack.h	193;"	d
STBRP_STATIC	imgui_draw.cpp	73;"	d	file:
STBRP__INIT_skyline	stb_rect_pack.h	/^   STBRP__INIT_skyline = 1$/;"	e	enum:__anon23
STBRP__MAXVAL	stb_rect_pack.h	532;"	d
STBRP__MAXVAL	stb_rect_pack.h	534;"	d
STBTT_DEF	stb_truetype.h	451;"	d
STBTT_DEF	stb_truetype.h	453;"	d
STBTT_FIX	stb_truetype.h	1678;"	d
STBTT_FIXMASK	stb_truetype.h	1679;"	d
STBTT_FIXSHIFT	stb_truetype.h	1677;"	d
STBTT_MACSTYLE_BOLD	stb_truetype.h	857;"	d
STBTT_MACSTYLE_DONTCARE	stb_truetype.h	856;"	d
STBTT_MACSTYLE_ITALIC	stb_truetype.h	858;"	d
STBTT_MACSTYLE_NONE	stb_truetype.h	860;"	d
STBTT_MACSTYLE_UNDERSCORE	stb_truetype.h	859;"	d
STBTT_MAC_EID_ARABIC	stb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon16
STBTT_MAC_EID_CHINESE_TRAD	stb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon16
STBTT_MAC_EID_GREEK	stb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon16
STBTT_MAC_EID_HEBREW	stb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon16
STBTT_MAC_EID_JAPANESE	stb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon16
STBTT_MAC_EID_KOREAN	stb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon16
STBTT_MAC_EID_ROMAN	stb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon16
STBTT_MAC_EID_RUSSIAN	stb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon16
STBTT_MAC_LANG_ARABIC	stb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon18
STBTT_MAC_LANG_CHINESE_SIMPLIFIED	stb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon18
STBTT_MAC_LANG_CHINESE_TRAD	stb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon18
STBTT_MAC_LANG_DUTCH	stb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon18
STBTT_MAC_LANG_ENGLISH	stb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon18
STBTT_MAC_LANG_FRENCH	stb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon18
STBTT_MAC_LANG_GERMAN	stb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon18
STBTT_MAC_LANG_HEBREW	stb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon18
STBTT_MAC_LANG_ITALIAN	stb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon18
STBTT_MAC_LANG_JAPANESE	stb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon18
STBTT_MAC_LANG_KOREAN	stb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon18
STBTT_MAC_LANG_RUSSIAN	stb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon18
STBTT_MAC_LANG_SPANISH	stb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon18
STBTT_MAC_LANG_SWEDISH	stb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon18
STBTT_MAX_OVERSAMPLE	stb_truetype.h	939;"	d
STBTT_MS_EID_SHIFTJIS	stb_truetype.h	/^   STBTT_MS_EID_SHIFTJIS      =2,$/;"	e	enum:__anon15
STBTT_MS_EID_SYMBOL	stb_truetype.h	/^   STBTT_MS_EID_SYMBOL        =0,$/;"	e	enum:__anon15
STBTT_MS_EID_UNICODE_BMP	stb_truetype.h	/^   STBTT_MS_EID_UNICODE_BMP   =1,$/;"	e	enum:__anon15
STBTT_MS_EID_UNICODE_FULL	stb_truetype.h	/^   STBTT_MS_EID_UNICODE_FULL  =10$/;"	e	enum:__anon15
STBTT_MS_LANG_CHINESE	stb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon17
STBTT_MS_LANG_DUTCH	stb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon17
STBTT_MS_LANG_ENGLISH	stb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon17
STBTT_MS_LANG_FRENCH	stb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon17
STBTT_MS_LANG_GERMAN	stb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon17
STBTT_MS_LANG_HEBREW	stb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon17
STBTT_MS_LANG_ITALIAN	stb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon17
STBTT_MS_LANG_JAPANESE	stb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon17
STBTT_MS_LANG_KOREAN	stb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon17
STBTT_MS_LANG_RUSSIAN	stb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon17
STBTT_MS_LANG_SPANISH	stb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon17
STBTT_MS_LANG_SWEDISH	stb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon17
STBTT_PLATFORM_ID_ISO	stb_truetype.h	/^   STBTT_PLATFORM_ID_ISO       =2,$/;"	e	enum:__anon13
STBTT_PLATFORM_ID_MAC	stb_truetype.h	/^   STBTT_PLATFORM_ID_MAC       =1,$/;"	e	enum:__anon13
STBTT_PLATFORM_ID_MICROSOFT	stb_truetype.h	/^   STBTT_PLATFORM_ID_MICROSOFT =3$/;"	e	enum:__anon13
STBTT_PLATFORM_ID_UNICODE	stb_truetype.h	/^   STBTT_PLATFORM_ID_UNICODE   =0,$/;"	e	enum:__anon13
STBTT_POINT_SIZE	stb_truetype.h	540;"	d
STBTT_RASTERIZER_VERSION	stb_truetype.h	949;"	d
STBTT_STATIC	imgui_draw.cpp	82;"	d	file:
STBTT_UNICODE_EID_ISO_10646	stb_truetype.h	/^   STBTT_UNICODE_EID_ISO_10646      =2,$/;"	e	enum:__anon14
STBTT_UNICODE_EID_UNICODE_1_0	stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_0    =0,$/;"	e	enum:__anon14
STBTT_UNICODE_EID_UNICODE_1_1	stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_1    =1,$/;"	e	enum:__anon14
STBTT_UNICODE_EID_UNICODE_2_0_BMP	stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,$/;"	e	enum:__anon14
STBTT_UNICODE_EID_UNICODE_2_0_FULL	stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4$/;"	e	enum:__anon14
STBTT__COMPARE	stb_truetype.h	2167;"	d
STBTT__NOTUSED	stb_truetype.h	2601;"	d
STBTT__NOTUSED	stb_truetype.h	2603;"	d
STBTT__OVER_MASK	stb_truetype.h	2723;"	d
STBTT_assert	imgui_draw.cpp	80;"	d	file:
STBTT_assert	stb_truetype.h	425;"	d
STBTT_fabs	stb_truetype.h	413;"	d
STBTT_free	imgui_draw.cpp	79;"	d	file:
STBTT_free	stb_truetype.h	420;"	d
STBTT_iceil	stb_truetype.h	403;"	d
STBTT_ifloor	stb_truetype.h	402;"	d
STBTT_malloc	imgui_draw.cpp	78;"	d	file:
STBTT_malloc	stb_truetype.h	419;"	d
STBTT_memcpy	stb_truetype.h	435;"	d
STBTT_memset	stb_truetype.h	436;"	d
STBTT_sqrt	stb_truetype.h	408;"	d
STBTT_strlen	stb_truetype.h	430;"	d
STBTT_vcurve	stb_truetype.h	/^      STBTT_vcurve$/;"	e	enum:__anon10
STBTT_vline	stb_truetype.h	/^      STBTT_vline,$/;"	e	enum:__anon10
STBTT_vmove	stb_truetype.h	/^      STBTT_vmove=1,$/;"	e	enum:__anon10
STB_INCLUDE_STB_RECT_PACK_H	stb_rect_pack.h	54;"	d
STB_RECT_PACK_IMPLEMENTATION	imgui_draw.cpp	74;"	d	file:
STB_RECT_PACK_VERSION	stb_rect_pack.h	56;"	d
STB_TEXTEDIT_CHARTYPE	imgui_internal.h	58;"	d
STB_TEXTEDIT_CHARTYPE	imgui_internal.h	60;"	d
STB_TEXTEDIT_CHARTYPE	stb_textedit.h	287;"	d
STB_TEXTEDIT_DELETECHARS	imgui.cpp	/^static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_GETCHAR	imgui.cpp	/^static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->Text[idx]; }$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_GETWIDTH	imgui.cpp	/^static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize \/ GImGui->Font->FontSize); }$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_GETWIDTH_NEWLINE	imgui_internal.h	61;"	d
STB_TEXTEDIT_IMPLEMENTATION	imgui.cpp	7167;"	d	file:
STB_TEXTEDIT_INSERTCHARS	imgui.cpp	/^static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_KEYTOTEXT	imgui.cpp	/^static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_K_BACKSPACE	imgui.cpp	7160;"	d	file:
STB_TEXTEDIT_K_DELETE	imgui.cpp	7159;"	d	file:
STB_TEXTEDIT_K_DOWN	imgui.cpp	7154;"	d	file:
STB_TEXTEDIT_K_LEFT	imgui.cpp	7151;"	d	file:
STB_TEXTEDIT_K_LINEEND	imgui.cpp	7156;"	d	file:
STB_TEXTEDIT_K_LINESTART	imgui.cpp	7155;"	d	file:
STB_TEXTEDIT_K_REDO	imgui.cpp	7162;"	d	file:
STB_TEXTEDIT_K_RIGHT	imgui.cpp	7152;"	d	file:
STB_TEXTEDIT_K_SHIFT	imgui.cpp	7165;"	d	file:
STB_TEXTEDIT_K_TEXTEND	imgui.cpp	7158;"	d	file:
STB_TEXTEDIT_K_TEXTSTART	imgui.cpp	7157;"	d	file:
STB_TEXTEDIT_K_UNDO	imgui.cpp	7161;"	d	file:
STB_TEXTEDIT_K_UP	imgui.cpp	7153;"	d	file:
STB_TEXTEDIT_K_WORDLEFT	imgui.cpp	7163;"	d	file:
STB_TEXTEDIT_K_WORDRIGHT	imgui.cpp	7164;"	d	file:
STB_TEXTEDIT_LAYOUTROW	imgui.cpp	/^static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_MOVEWORDLEFT	imgui.cpp	7110;"	d	file:
STB_TEXTEDIT_MOVEWORDLEFT	stb_textedit.h	635;"	d
STB_TEXTEDIT_MOVEWORDLEFT_IMPL	imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_MOVEWORDRIGHT	imgui.cpp	7111;"	d	file:
STB_TEXTEDIT_MOVEWORDRIGHT	stb_textedit.h	650;"	d
STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_NEWLINE	imgui.cpp	/^static ImWchar STB_TEXTEDIT_NEWLINE = '\\n';$/;"	m	namespace:ImGuiStb	file:
STB_TEXTEDIT_POSITIONTYPE	stb_textedit.h	290;"	d
STB_TEXTEDIT_STRING	imgui_internal.h	57;"	d
STB_TEXTEDIT_STRING	imgui_internal.h	59;"	d
STB_TEXTEDIT_STRINGLEN	imgui.cpp	/^static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }$/;"	f	namespace:ImGuiStb
STB_TEXTEDIT_UNDOCHARCOUNT	stb_textedit.h	284;"	d
STB_TEXTEDIT_UNDOSTATECOUNT	stb_textedit.h	281;"	d
STB_TEXTEDIT_memmove	stb_textedit.h	378;"	d
STB_TEXT_HAS_SELECTION	stb_textedit.h	545;"	d
STB_TRUETYPE_IMPLEMENTATION	imgui_draw.cpp	83;"	d	file:
STB_TexteditState	stb_textedit.h	/^} STB_TexteditState;$/;"	t	typeref:struct:__anon3
STB__SCRAMBLE	extra_fonts/binary_to_compressed_c.cpp	234;"	d	file:
STB__TRY	extra_fonts/binary_to_compressed_c.cpp	252;"	d	file:
SameLine	imgui.cpp	/^void ImGui::SameLine(float pos_x, float spacing_w)$/;"	f	class:ImGui
SaveSettings	imgui.cpp	/^static void SaveSettings()$/;"	f	file:
ScalarAsInputTextId	imgui_internal.h	/^    ImGuiID                 ScalarAsInputTextId;                \/\/ Temporary text input when CTRL+clicking on a slider, etc.$/;"	m	struct:ImGuiState
Scale	imgui.h	/^    float                       Scale;              \/\/ = 1.0f          \/\/ Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()$/;"	m	struct:ImFont
ScaleClipRects	imgui_draw.cpp	/^void ImDrawData::ScaleClipRects(const ImVec2& scale)$/;"	f	class:ImDrawData
Scroll	imgui_internal.h	/^    ImVec2                  Scroll;$/;"	m	struct:ImGuiWindow
ScrollTarget	imgui_internal.h	/^    ImVec2                  ScrollTarget;                       \/\/ target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)$/;"	m	struct:ImGuiWindow
ScrollTargetCenterRatio	imgui_internal.h	/^    ImVec2                  ScrollTargetCenterRatio;            \/\/ 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered$/;"	m	struct:ImGuiWindow
ScrollToBottom	imgui_demo.cpp	/^    bool                  ScrollToBottom;$/;"	m	struct:ExampleAppConsole	file:
ScrollToBottom	imgui_demo.cpp	/^    bool                ScrollToBottom;$/;"	m	struct:ExampleAppLog	file:
ScrollX	imgui_internal.h	/^    float               ScrollX;$/;"	m	struct:ImGuiTextEditState
Scrollbar	imgui.cpp	/^static void Scrollbar(ImGuiWindow* window, bool horizontal)$/;"	f	file:
ScrollbarClickDeltaToGrabCenter	imgui_internal.h	/^    ImVec2                  ScrollbarClickDeltaToGrabCenter;   \/\/ Distance between mouse and center of grab box, normalized in parent space. Use storage?$/;"	m	struct:ImGuiState
ScrollbarRounding	imgui.h	/^    float       ScrollbarRounding;          \/\/ Radius of grab corners for scrollbar$/;"	m	struct:ImGuiStyle
ScrollbarSize	imgui.h	/^    float       ScrollbarSize;              \/\/ Width of the vertical scrollbar, Height of the horizontal scrollbar$/;"	m	struct:ImGuiStyle
ScrollbarSizes	imgui_internal.h	/^    ImVec2                  ScrollbarSizes;$/;"	m	struct:ImGuiWindow
ScrollbarX	imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;$/;"	m	struct:ImGuiWindow
ScrollbarY	imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;$/;"	m	struct:ImGuiWindow
SelectAll	imgui_internal.h	/^    void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }$/;"	f	struct:ImGuiTextEditState
Selectable	imgui.cpp	/^bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui
Selectable	imgui.cpp	/^bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui
SelectedAllMouseLock	imgui_internal.h	/^    bool                SelectedAllMouseLock;$/;"	m	struct:ImGuiTextEditState
SelectionEnd	imgui.h	/^    int                 SelectionEnd;   \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData
SelectionStart	imgui.h	/^    int                 SelectionStart; \/\/                                      \/\/ Read-write (== to SelectionEnd when no selection)$/;"	m	struct:ImGuiTextEditCallbackData
Separator	imgui.cpp	/^void ImGui::Separator()$/;"	f	class:ImGui
SetActiveID	imgui.cpp	/^void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window = NULL)$/;"	f	class:ImGui
SetAllInt	imgui.cpp	/^void ImGuiStorage::SetAllInt(int v)$/;"	f	class:ImGuiStorage
SetClipboardText	imgui.cpp	/^void ImGui::SetClipboardText(const char* text)$/;"	f	class:ImGui
SetClipboardTextFn	imgui.h	/^    void        (*SetClipboardTextFn)(const char* text);$/;"	m	struct:ImGuiIO
SetClipboardTextFn_DefaultImpl	imgui.cpp	/^static void SetClipboardTextFn_DefaultImpl(const char* text)$/;"	f	file:
SetColumnOffset	imgui.cpp	/^void ImGui::SetColumnOffset(int column_index, float offset)$/;"	f	class:ImGui
SetCurrentFont	imgui.cpp	/^static void SetCurrentFont(ImFont* font)$/;"	f	file:
SetCurrentWindow	imgui.cpp	/^static void SetCurrentWindow(ImGuiWindow* window)$/;"	f	file:
SetCursorPos	imgui.cpp	/^void ImGui::SetCursorPos(const ImVec2& local_pos)$/;"	f	class:ImGui
SetCursorPosX	imgui.cpp	/^void ImGui::SetCursorPosX(float x)$/;"	f	class:ImGui
SetCursorPosY	imgui.cpp	/^void ImGui::SetCursorPosY(float y)$/;"	f	class:ImGui
SetCursorScreenPos	imgui.cpp	/^void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)$/;"	f	class:ImGui
SetFallbackChar	imgui_draw.cpp	/^void ImFont::SetFallbackChar(ImWchar c)$/;"	f	class:ImFont
SetFloat	imgui.cpp	/^void ImGuiStorage::SetFloat(ImU32 key, float val)$/;"	f	class:ImGuiStorage
SetHSV	imgui.h	/^    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }$/;"	f	struct:ImColor
SetHoveredID	imgui.cpp	/^void ImGui::SetHoveredID(ImGuiID id)$/;"	f	class:ImGui
SetInt	imgui.cpp	/^void ImGuiStorage::SetInt(ImU32 key, int val)$/;"	f	class:ImGuiStorage
SetInternalState	imgui.cpp	/^void ImGui::SetInternalState(void* state, bool construct)$/;"	f	class:ImGui
SetItemAllowOverlap	imgui.cpp	/^void ImGui::SetItemAllowOverlap()$/;"	f	class:ImGui
SetKeyboardFocusHere	imgui.cpp	/^void ImGui::SetKeyboardFocusHere(int offset)$/;"	f	class:ImGui
SetMouseCursor	imgui.cpp	/^void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)$/;"	f	class:ImGui
SetNextTreeNodeOpened	imgui.cpp	/^void ImGui::SetNextTreeNodeOpened(bool opened, ImGuiSetCond cond)$/;"	f	class:ImGui
SetNextTreeNodeOpenedCond	imgui_internal.h	/^    ImGuiSetCond            SetNextTreeNodeOpenedCond;$/;"	m	struct:ImGuiState
SetNextTreeNodeOpenedVal	imgui_internal.h	/^    bool                    SetNextTreeNodeOpenedVal;$/;"	m	struct:ImGuiState
SetNextWindowCollapsed	imgui.cpp	/^void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui
SetNextWindowCollapsedCond	imgui_internal.h	/^    ImGuiSetCond            SetNextWindowCollapsedCond;$/;"	m	struct:ImGuiState
SetNextWindowCollapsedVal	imgui_internal.h	/^    bool                    SetNextWindowCollapsedVal;$/;"	m	struct:ImGuiState
SetNextWindowContentSize	imgui.cpp	/^void ImGui::SetNextWindowContentSize(const ImVec2& size)$/;"	f	class:ImGui
SetNextWindowContentSizeCond	imgui_internal.h	/^    ImGuiSetCond            SetNextWindowContentSizeCond;$/;"	m	struct:ImGuiState
SetNextWindowContentSizeVal	imgui_internal.h	/^    ImVec2                  SetNextWindowContentSizeVal;$/;"	m	struct:ImGuiState
SetNextWindowContentWidth	imgui.cpp	/^void ImGui::SetNextWindowContentWidth(float width)$/;"	f	class:ImGui
SetNextWindowFocus	imgui.cpp	/^void ImGui::SetNextWindowFocus()$/;"	f	class:ImGui
SetNextWindowFocus	imgui_internal.h	/^    bool                    SetNextWindowFocus;$/;"	m	struct:ImGuiState
SetNextWindowPos	imgui.cpp	/^void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui
SetNextWindowPosCenter	imgui.cpp	/^void ImGui::SetNextWindowPosCenter(ImGuiSetCond cond)$/;"	f	class:ImGui
SetNextWindowPosCond	imgui_internal.h	/^    ImGuiSetCond            SetNextWindowPosCond;$/;"	m	struct:ImGuiState
SetNextWindowPosVal	imgui_internal.h	/^    ImVec2                  SetNextWindowPosVal;$/;"	m	struct:ImGuiState
SetNextWindowSize	imgui.cpp	/^void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui
SetNextWindowSizeCond	imgui_internal.h	/^    ImGuiSetCond            SetNextWindowSizeCond;$/;"	m	struct:ImGuiState
SetNextWindowSizeVal	imgui_internal.h	/^    ImVec2                  SetNextWindowSizeVal;$/;"	m	struct:ImGuiState
SetScrollFromPosY	imgui.cpp	/^void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)$/;"	f	class:ImGui
SetScrollHere	imgui.cpp	/^void ImGui::SetScrollHere(float center_y_ratio)$/;"	f	class:ImGui
SetScrollPosHere	imgui.h	/^    static inline void      SetScrollPosHere() { SetScrollHere(); }                            \/\/ OBSOLETE 1.42+$/;"	f	namespace:ImGui
SetScrollX	imgui.cpp	/^void ImGui::SetScrollX(float scroll_x)$/;"	f	class:ImGui
SetScrollY	imgui.cpp	/^void ImGui::SetScrollY(float scroll_y)$/;"	f	class:ImGui
SetStateStorage	imgui.cpp	/^void ImGui::SetStateStorage(ImGuiStorage* tree)$/;"	f	class:ImGui
SetTexID	imgui.h	/^    void                        SetTexID(void* id)  { TexID = id; }$/;"	f	struct:ImFontAtlas
SetTooltip	imgui.cpp	/^void ImGui::SetTooltip(const char* fmt, ...)$/;"	f	class:ImGui
SetTooltipV	imgui.cpp	/^void ImGui::SetTooltipV(const char* fmt, va_list args)$/;"	f	class:ImGui
SetUpLights	render2d.cpp	/^void SetUpLights() {$/;"	f
SetUpLights	render3d.cpp	/^void SetUpLights() {$/;"	f
SetUpOpenGL	render2d.cpp	/^void SetUpOpenGL() {$/;"	f
SetUpOpenGL	render3d.cpp	/^void SetUpOpenGL() {$/;"	f
SetVoidPtr	imgui.cpp	/^void ImGuiStorage::SetVoidPtr(ImU32 key, void* val)$/;"	f	class:ImGuiStorage
SetWindowCollapsed	imgui.cpp	/^static void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiSetCond cond)$/;"	f	file:
SetWindowCollapsed	imgui.cpp	/^void ImGui::SetWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui
SetWindowCollapsed	imgui.cpp	/^void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui
SetWindowCollapsedAllowFlags	imgui_internal.h	/^    int                     SetWindowCollapsedAllowFlags;       \/\/ bit ImGuiSetCond_*** specify if SetWindowCollapsed() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow
SetWindowFocus	imgui.cpp	/^void ImGui::SetWindowFocus()$/;"	f	class:ImGui
SetWindowFocus	imgui.cpp	/^void ImGui::SetWindowFocus(const char* name)$/;"	f	class:ImGui
SetWindowFontScale	imgui.cpp	/^void ImGui::SetWindowFontScale(float scale)$/;"	f	class:ImGui
SetWindowPos	imgui.cpp	/^static void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiSetCond cond)$/;"	f	file:
SetWindowPos	imgui.cpp	/^void ImGui::SetWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui
SetWindowPos	imgui.cpp	/^void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui
SetWindowPosAllowFlags	imgui_internal.h	/^    int                     SetWindowPosAllowFlags;             \/\/ bit ImGuiSetCond_*** specify if SetWindowPos() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow
SetWindowPosCenterWanted	imgui_internal.h	/^    bool                    SetWindowPosCenterWanted;$/;"	m	struct:ImGuiWindow
SetWindowScrollY	imgui.cpp	/^static void SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)$/;"	f	file:
SetWindowSize	imgui.cpp	/^static void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiSetCond cond)$/;"	f	file:
SetWindowSize	imgui.cpp	/^void ImGui::SetWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui
SetWindowSize	imgui.cpp	/^void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui
SetWindowSizeAllowFlags	imgui_internal.h	/^    int                     SetWindowSizeAllowFlags;            \/\/ bit ImGuiSetCond_*** specify if SetWindowSize() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow
Settings	imgui_internal.h	/^    ImVector<ImGuiIniData>  Settings;                           \/\/ .ini Settings$/;"	m	struct:ImGuiState
SettingsDirtyTimer	imgui_internal.h	/^    float                   SettingsDirtyTimer;                 \/\/ Save .ini settinngs on disk when time reaches zero$/;"	m	struct:ImGuiState
ShortcutsUseSuperKey	imgui.h	/^    bool          ShortcutsUseSuperKey;     \/\/ = defined(__APPLE__) \/\/ OS X style: Shortcuts using Cmd\/Super instead of Ctrl$/;"	m	struct:ImGuiIO
ShowControl	ui.cpp	/^void ShowControl(bool* opened, AppStateAndEvents &ae) {$/;"	f
ShowExampleAppAutoResize	imgui_demo.cpp	/^static void ShowExampleAppAutoResize(bool* opened)$/;"	f	file:
ShowExampleAppConsole	imgui_demo.cpp	/^static void ShowExampleAppConsole(bool* opened)$/;"	f	file:
ShowExampleAppCustomRendering	imgui_demo.cpp	/^static void ShowExampleAppCustomRendering(bool* opened)$/;"	f	file:
ShowExampleAppFixedOverlay	imgui_demo.cpp	/^static void ShowExampleAppFixedOverlay(bool* opened)$/;"	f	file:
ShowExampleAppLayout	imgui_demo.cpp	/^static void ShowExampleAppLayout(bool* opened)$/;"	f	file:
ShowExampleAppLog	imgui_demo.cpp	/^static void ShowExampleAppLog(bool* opened)$/;"	f	file:
ShowExampleAppLongText	imgui_demo.cpp	/^static void ShowExampleAppLongText(bool* opened)$/;"	f	file:
ShowExampleAppMainMenuBar	imgui_demo.cpp	/^static void ShowExampleAppMainMenuBar()$/;"	f	file:
ShowExampleAppManipulatingWindowTitle	imgui_demo.cpp	/^static void ShowExampleAppManipulatingWindowTitle(bool* opened)$/;"	f	file:
ShowExampleAppPropertyEditor	imgui_demo.cpp	/^static void ShowExampleAppPropertyEditor(bool* opened)$/;"	f	file:
ShowExampleMenuFile	imgui_demo.cpp	/^static void ShowExampleMenuFile()$/;"	f	file:
ShowGoals	ui.cpp	/^void ShowGoals(bool* opened) {$/;"	f
ShowHelp	ui.cpp	/^void ShowHelp(bool* opened) {$/;"	f
ShowHelpMarker	imgui_demo.cpp	/^static void ShowHelpMarker(const char* desc)$/;"	f	file:
ShowMetricsWindow	imgui.cpp	/^void ImGui::ShowMetricsWindow(bool* opened)$/;"	f	class:ImGui
ShowModeler	ui.cpp	/^void ShowModeler(bool* opened, AppStateAndEvents &ae) {$/;"	f
ShowStyleEditor	imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle* ref)$/;"	f	class:ImGui
ShowStyleEditor	imgui_demo.cpp	/^void ImGui::ShowStyleEditor(bool*) {}$/;"	f	class:ImGui
ShowTestWindow	imgui_demo.cpp	/^void ImGui::ShowTestWindow(bool* p_opened)$/;"	f	class:ImGui
ShowTestWindow	imgui_demo.cpp	/^void ImGui::ShowTestWindow(bool*) {}$/;"	f	class:ImGui
ShowUserGuide	imgui_demo.cpp	/^void ImGui::ShowUserGuide()$/;"	f	class:ImGui
ShowUserGuide	imgui_demo.cpp	/^void ImGui::ShowUserGuide(bool*) {}$/;"	f	class:ImGui
Shutdown	imgui.cpp	/^void ImGui::Shutdown()$/;"	f	class:ImGui
Size	imgui.h	/^    int                         Size;$/;"	m	class:ImVector
Size	imgui_internal.h	/^    ImVec2                  Size;                               \/\/ Current size (==SizeFull or collapsed title bar size)$/;"	m	struct:ImGuiWindow
Size	imgui_internal.h	/^    ImVec2              Size;$/;"	m	struct:ImGuiMouseCursorData
Size	imgui_internal.h	/^    ImVec2      Size;$/;"	m	struct:ImGuiIniData
SizeContents	imgui_internal.h	/^    ImVec2                  SizeContents;                       \/\/ Size of contents (== extents reach of the drawing cursor) from previous frame$/;"	m	struct:ImGuiWindow
SizeContentsExplicit	imgui_internal.h	/^    ImVec2                  SizeContentsExplicit;               \/\/ Size of contents explicitly set by the user via SetNextWindowContentSize()$/;"	m	struct:ImGuiWindow
SizeFull	imgui_internal.h	/^    ImVec2                  SizeFull;                           \/\/ Size when non collapsed$/;"	m	struct:ImGuiWindow
SizePixels	imgui.h	/^    float           SizePixels;                 \/\/          \/\/ Size in pixels for rasterizer$/;"	m	struct:ImFontConfig
SkipItems	imgui_internal.h	/^    bool                    SkipItems;                          \/\/ == Visible && !Collapsed$/;"	m	struct:ImGuiWindow
SliderAngle	imgui.cpp	/^bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)$/;"	f	class:ImGui
SliderBehavior	imgui.cpp	/^bool ImGui::SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderFloat	imgui.cpp	/^bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
SliderFloat2	imgui.cpp	/^bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
SliderFloat3	imgui.cpp	/^bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
SliderFloat4	imgui.cpp	/^bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
SliderFloatN	imgui.cpp	/^bool ImGui::SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
SliderInt	imgui.cpp	/^bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
SliderInt2	imgui.cpp	/^bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
SliderInt3	imgui.cpp	/^bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
SliderInt4	imgui.cpp	/^bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
SliderIntN	imgui.cpp	/^bool ImGui::SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
SmallButton	imgui.cpp	/^bool ImGui::SmallButton(const char* label)$/;"	f	class:ImGui
Spacing	imgui.cpp	/^void ImGui::Spacing()$/;"	f	class:ImGui
Spacing	imgui_internal.h	/^    float       Spacing;$/;"	m	struct:ImGuiSimpleColumns
StackSizesBackup	imgui_internal.h	/^    int                     StackSizesBackup[6];    \/\/ Store size of various stacks for asserting$/;"	m	struct:ImGuiDrawContext
StateStorage	imgui_internal.h	/^    ImGuiStorage            StateStorage;$/;"	m	struct:ImGuiWindow
StateStorage	imgui_internal.h	/^    ImGuiStorage*           StateStorage;$/;"	m	struct:ImGuiDrawContext
StbFindState	stb_textedit.h	/^} StbFindState;$/;"	t	typeref:struct:__anon5
StbState	imgui_internal.h	/^    ImGuiStb::STB_TexteditState   StbState;$/;"	m	struct:ImGuiTextEditState
StbTexteditRow	stb_textedit.h	/^} StbTexteditRow;$/;"	t	typeref:struct:__anon4
StbUndoRecord	stb_textedit.h	/^} StbUndoRecord;$/;"	t	typeref:struct:__anon1
StbUndoState	stb_textedit.h	/^} StbUndoState;$/;"	t	typeref:struct:__anon2
Strdup	imgui_demo.cpp	/^    static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }$/;"	f	struct:ExampleAppConsole
Stricmp	imgui_demo.cpp	/^    static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }$/;"	f	struct:ExampleAppConsole
Stride	imgui.cpp	/^    int Stride;$/;"	m	struct:ImGuiPlotArrayGetterData	file:
Strnicmp	imgui_demo.cpp	/^    static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }$/;"	f	struct:ExampleAppConsole
Style	imgui_internal.h	/^    ImGuiStyle              Style;$/;"	m	struct:ImGuiState
StyleModifiers	imgui_internal.h	/^    ImVector<ImGuiStyleMod> StyleModifiers;                     \/\/ Stack for PushStyleVar()\/PopStyleVar()$/;"	m	struct:ImGuiState
T	render2d.cpp	/^float t, T = 0.0;$/;"	v
T	render3d.cpp	/^float t, T = 0.0;$/;"	v
TempBuffer	imgui_internal.h	/^    char                    TempBuffer[1024*3+1];               \/\/ temporary text buffer$/;"	m	struct:ImGuiState
TempTextBuffer	imgui_internal.h	/^    ImVector<char>      TempTextBuffer;$/;"	m	struct:ImGuiTextEditState
TexDesiredWidth	imgui.h	/^    int                         TexDesiredWidth;    \/\/ Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.$/;"	m	struct:ImFontAtlas
TexHeight	imgui.h	/^    int                         TexHeight;          \/\/ Texture height calculated during Build().$/;"	m	struct:ImFontAtlas
TexID	imgui.h	/^    void*                       TexID;              \/\/ User data to refer to the texture once it has been uploaded to user's graphic systems. It ia passed back to you during rendering.$/;"	m	struct:ImFontAtlas
TexPixelsAlpha8	imgui.h	/^    unsigned char*              TexPixelsAlpha8;    \/\/ 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight$/;"	m	struct:ImFontAtlas
TexPixelsRGBA32	imgui.h	/^    unsigned int*               TexPixelsRGBA32;    \/\/ 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4$/;"	m	struct:ImFontAtlas
TexUvMax	imgui_internal.h	/^    ImVec2              TexUvMax[2];$/;"	m	struct:ImGuiMouseCursorData
TexUvMin	imgui_internal.h	/^    ImVec2              TexUvMin[2];$/;"	m	struct:ImGuiMouseCursorData
TexUvWhitePixel	imgui.h	/^    ImVec2                      TexUvWhitePixel;    \/\/ Texture coordinates to a white pixel$/;"	m	struct:ImFontAtlas
TexWidth	imgui.h	/^    int                         TexWidth;           \/\/ Texture width calculated during Build().$/;"	m	struct:ImFontAtlas
Text	imgui.cpp	/^void ImGui::Text(const char* fmt, ...)$/;"	f	class:ImGui
Text	imgui_internal.h	/^    ImVector<ImWchar>   Text;                       \/\/ edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.$/;"	m	struct:ImGuiTextEditState
TextColored	imgui.cpp	/^void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)$/;"	f	class:ImGui
TextColoredV	imgui.cpp	/^void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)$/;"	f	class:ImGui
TextDisabled	imgui.cpp	/^void ImGui::TextDisabled(const char* fmt, ...)$/;"	f	class:ImGui
TextDisabledV	imgui.cpp	/^void ImGui::TextDisabledV(const char* fmt, va_list args)$/;"	f	class:ImGui
TextEditCallback	imgui_demo.cpp	/^    int     TextEditCallback(ImGuiTextEditCallbackData* data)$/;"	f	struct:ExampleAppConsole
TextEditCallbackStub	imgui_demo.cpp	/^    static int TextEditCallbackStub(ImGuiTextEditCallbackData* data) \/\/ In C++11 you are better off using lambdas for this sort of forwarding callbacks$/;"	f	struct:ExampleAppConsole
TextRange	imgui.h	/^        TextRange() { b = e = NULL; }$/;"	f	struct:ImGuiTextFilter::TextRange
TextRange	imgui.h	/^        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }$/;"	f	struct:ImGuiTextFilter::TextRange
TextRange	imgui.h	/^    struct TextRange$/;"	s	struct:ImGuiTextFilter
TextUnformatted	imgui.cpp	/^void ImGui::TextUnformatted(const char* text, const char* text_end)$/;"	f	class:ImGui
TextV	imgui.cpp	/^void ImGui::TextV(const char* fmt, va_list args)$/;"	f	class:ImGui
TextWrapPos	imgui_internal.h	/^    float                   TextWrapPos;            \/\/ == TextWrapPosStack.back() [empty == -1.0f]$/;"	m	struct:ImGuiDrawContext
TextWrapPosStack	imgui_internal.h	/^    ImVector<float>         TextWrapPosStack;$/;"	m	struct:ImGuiDrawContext
TextWrapped	imgui.cpp	/^void ImGui::TextWrapped(const char* fmt, ...)$/;"	f	class:ImGui
TextWrappedV	imgui.cpp	/^void ImGui::TextWrappedV(const char* fmt, va_list args)$/;"	f	class:ImGui
TextureId	imgui.h	/^    ImTextureID     TextureId;              \/\/ User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.$/;"	m	struct:ImDrawCmd
Time	imgui_internal.h	/^    float                   Time;$/;"	m	struct:ImGuiState
TitleBarHeight	imgui_internal.h	/^    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }$/;"	f	struct:ImGuiWindow
TitleBarRect	imgui_internal.h	/^    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }$/;"	f	struct:ImGuiWindow
Tooltip	imgui_internal.h	/^    char                    Tooltip[1024];$/;"	m	struct:ImGuiState
TotalIdxCount	imgui.h	/^    int             TotalIdxCount;          \/\/ For convenience, sum of all cmd_lists idx_buffer.Size$/;"	m	struct:ImDrawData
TotalVtxCount	imgui.h	/^    int             TotalVtxCount;          \/\/ For convenience, sum of all cmd_lists vtx_buffer.Size$/;"	m	struct:ImDrawData
TouchExtraPadding	imgui.h	/^    ImVec2      TouchExtraPadding;          \/\/ Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!$/;"	m	struct:ImGuiStyle
TreeDepth	imgui_internal.h	/^    int                     TreeDepth;$/;"	m	struct:ImGuiDrawContext
TreeNode	imgui.cpp	/^bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)$/;"	f	class:ImGui
TreeNode	imgui.cpp	/^bool ImGui::TreeNode(const char* str_label_id)$/;"	f	class:ImGui
TreeNode	imgui.cpp	/^bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)$/;"	f	class:ImGui
TreeNodeBehaviorIsOpened	imgui.cpp	/^bool ImGui::TreeNodeBehaviorIsOpened(ImGuiID id, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
TreeNodeV	imgui.cpp	/^bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)$/;"	f	class:ImGui
TreeNodeV	imgui.cpp	/^bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)$/;"	f	class:ImGui
TreePop	imgui.cpp	/^void ImGui::TreePop()$/;"	f	class:ImGui
TreePush	imgui.cpp	/^void ImGui::TreePush(const char* str_id)$/;"	f	class:ImGui
TreePush	imgui.cpp	/^void ImGui::TreePush(const void* ptr_id)$/;"	f	class:ImGui
Type	imgui_internal.h	/^    ImGuiMouseCursor    Type;$/;"	m	struct:ImGuiMouseCursorData
U0	imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph
U1	imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph
UI_H	ui.h	2;"	d
Unindent	imgui.cpp	/^void ImGui::Unindent()$/;"	f	class:ImGui
Update	imgui.cpp	/^void ImGuiSimpleColumns::Update(int count, float spacing, bool clear)$/;"	f	class:ImGuiSimpleColumns
UpdateClipRect	imgui_draw.cpp	/^void ImDrawList::UpdateClipRect()$/;"	f	class:ImDrawList
UpdateTextureID	imgui_draw.cpp	/^void ImDrawList::UpdateTextureID()$/;"	f	class:ImDrawList
UserCallback	imgui.h	/^    ImDrawCallback  UserCallback;           \/\/ If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.$/;"	m	struct:ImDrawCmd
UserCallbackData	imgui.h	/^    void*           UserCallbackData;       \/\/ The draw callback code can access this.$/;"	m	struct:ImDrawCmd
UserData	imgui.h	/^    void*               UserData;       \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData
UserData	imgui.h	/^    void*         UserData;                 \/\/ = NULL               \/\/ Store your own data for retrieval by callbacks.$/;"	m	struct:ImGuiIO
V0	imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph
V1	imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph
VSliderFloat	imgui.cpp	/^bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui
VSliderInt	imgui.cpp	/^bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui
Valid	imgui.h	/^    bool            Valid;                  \/\/ Only valid after Render() is called and before the next NewFrame() is called.$/;"	m	struct:ImDrawData
Value	imgui.cpp	/^void ImGui::Value(const char* prefix, bool b)$/;"	f	class:ImGui
Value	imgui.cpp	/^void ImGui::Value(const char* prefix, float v, const char* float_format)$/;"	f	class:ImGui
Value	imgui.cpp	/^void ImGui::Value(const char* prefix, int v)$/;"	f	class:ImGui
Value	imgui.cpp	/^void ImGui::Value(const char* prefix, unsigned int v)$/;"	f	class:ImGui
Value	imgui.h	/^    ImVec4              Value;$/;"	m	struct:ImColor
ValueColor	imgui.cpp	/^void ImGui::ValueColor(const char* prefix, const ImVec4& v)$/;"	f	class:ImGui
ValueColor	imgui.cpp	/^void ImGui::ValueColor(const char* prefix, unsigned int v)$/;"	f	class:ImGui
Values	imgui.cpp	/^    const float* Values;$/;"	m	struct:ImGuiPlotArrayGetterData	file:
Var	imgui_internal.h	/^    ImGuiStyleVar   Var;$/;"	m	struct:ImGuiStyleMod
VtxBuffer	imgui.h	/^    ImVector<ImDrawVert>    VtxBuffer;          \/\/ Vertex buffer.$/;"	m	struct:ImDrawList
WIN32_LEAN_AND_MEAN	imgui.cpp	9190;"	d	file:
WIN32_LEAN_AND_MEAN	imgui.cpp	9191;"	d	file:
WantCaptureKeyboard	imgui.h	/^    bool        WantCaptureKeyboard;        \/\/ Widget is active (= ImGui will use your keyboard input)$/;"	m	struct:ImGuiIO
WantCaptureMouse	imgui.h	/^    bool        WantCaptureMouse;           \/\/ Mouse is hovering a window or widget is active (= ImGui will use your mouse input)$/;"	m	struct:ImGuiIO
WantTextInput	imgui.h	/^    bool        WantTextInput;              \/\/ Some text input widget is active, which will read input characters from the InputCharacters array.$/;"	m	struct:ImGuiIO
WasActive	imgui_internal.h	/^    bool                    WasActive;$/;"	m	struct:ImGuiWindow
Width	imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns
Window	imgui_internal.h	/^    ImGuiWindow*    Window;         \/\/ Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()$/;"	m	struct:ImGuiPopupRef
WindowMinSize	imgui.h	/^    ImVec2      WindowMinSize;              \/\/ Minimum window size$/;"	m	struct:ImGuiStyle
WindowPadding	imgui.h	/^    ImVec2      WindowPadding;              \/\/ Padding within a window$/;"	m	struct:ImGuiStyle
WindowPadding	imgui_internal.h	/^    ImVec2                  WindowPadding;                      \/\/ Window padding at the time of begin. We need to lock it, in particular manipulation of the ShowBorder would have an effect$/;"	m	struct:ImGuiWindow
WindowRounding	imgui.h	/^    float       WindowRounding;             \/\/ Radius of window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle
WindowTitleAlign	imgui.h	/^    ImGuiAlign  WindowTitleAlign;           \/\/ Alignment for title bar text$/;"	m	struct:ImGuiStyle
Windows	imgui_internal.h	/^    ImVector<ImGuiWindow*>  Windows;$/;"	m	struct:ImGuiState
WindowsSortBuffer	imgui_internal.h	/^    ImVector<ImGuiWindow*>  WindowsSortBuffer;$/;"	m	struct:ImGuiState
WordMovementUsesAltKey	imgui.h	/^    bool          WordMovementUsesAltKey;   \/\/ = defined(__APPLE__) \/\/ OS X style: Text editing cursor movement using Alt instead of Ctrl$/;"	m	struct:ImGuiIO
X0	imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph
X1	imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph
XAdvance	imgui.h	/^        float                   XAdvance;$/;"	m	struct:ImFont::Glyph
Y0	imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph
Y1	imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph
_BLENDER_EXPORT_H_	palace.h	2;"	d
_BLENDER_EXPORT_H_	untitled.h	2;"	d
_CRT_SECURE_NO_WARNINGS	extra_fonts/binary_to_compressed_c.cpp	10;"	d	file:
_CRT_SECURE_NO_WARNINGS	imgui.cpp	571;"	d	file:
_CRT_SECURE_NO_WARNINGS	imgui_demo.cpp	9;"	d	file:
_CRT_SECURE_NO_WARNINGS	imgui_draw.cpp	12;"	d	file:
_Channels	imgui.h	/^    ImVector<ImDrawChannel> _Channels;          \/\/ [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)$/;"	m	struct:ImDrawList
_ChannelsCount	imgui.h	/^    int                     _ChannelsCount;     \/\/ [Internal] number of active channels (1+)$/;"	m	struct:ImDrawList
_ChannelsCurrent	imgui.h	/^    int                     _ChannelsCurrent;   \/\/ [Internal] current channel number (0)$/;"	m	struct:ImDrawList
_ClipRectStack	imgui.h	/^    ImVector<ImVec4>        _ClipRectStack;     \/\/ [Internal]$/;"	m	struct:ImDrawList
_IdxWritePtr	imgui.h	/^    ImDrawIdx*              _IdxWritePtr;       \/\/ [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList
_OwnerName	imgui.h	/^    const char*             _OwnerName;         \/\/ Pointer to owner window's name (if any) for debugging$/;"	m	struct:ImDrawList
_Path	imgui.h	/^    ImVector<ImVec2>        _Path;              \/\/ [Internal] current path building$/;"	m	struct:ImDrawList
_TextureIdStack	imgui.h	/^    ImVector<ImTextureID>   _TextureIdStack;    \/\/ [Internal]$/;"	m	struct:ImDrawList
_VtxCurrentIdx	imgui.h	/^    unsigned int            _VtxCurrentIdx;     \/\/ [Internal] == VtxBuffer.Size$/;"	m	struct:ImDrawList
_VtxWritePtr	imgui.h	/^    ImDrawVert*             _VtxWritePtr;       \/\/ [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList
__STB_INCLUDE_STB_TRUETYPE_H__	stb_truetype.h	448;"	d
_grow_capacity	imgui.h	/^    inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity\/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }$/;"	f	class:ImVector
active_head	stb_rect_pack.h	/^   stbrp_node *active_head;$/;"	m	struct:stbrp_context
align	stb_rect_pack.h	/^   int align;$/;"	m	struct:stbrp_context
append	imgui.cpp	/^void ImGuiTextBuffer::append(const char* fmt, ...)$/;"	f	class:ImGuiTextBuffer
appendv	imgui.cpp	/^void ImGuiTextBuffer::appendv(const char* fmt, va_list args)$/;"	f	class:ImGuiTextBuffer
array_of_unicode_codepoints	stb_truetype.h	/^   int *array_of_unicode_codepoints;       \/\/ if non-zero, then this is an array of unicode codepoints$/;"	m	struct:__anon9
b	imgui.h	/^        const char* b;$/;"	m	struct:ImGuiTextFilter::TextRange
back	imgui.h	/^    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector
back	imgui.h	/^    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector
baseline_y_delta	stb_textedit.h	/^   float baseline_y_delta;  \/\/ position of baseline relative to previous row's baseline$/;"	m	struct:__anon4
begin	imgui.h	/^        const char* begin() const { return b; }$/;"	f	struct:ImGuiTextFilter::TextRange
begin	imgui.h	/^    const char*         begin() const { return &Buf.front(); }$/;"	f	struct:ImGuiTextBuffer
begin	imgui.h	/^    inline const_iterator       begin() const                   { return Data; }$/;"	f	class:ImVector
begin	imgui.h	/^    inline iterator             begin()                         { return Data; }$/;"	f	class:ImVector
binary_to_compressed_c	extra_fonts/binary_to_compressed_c.cpp	/^bool binary_to_compressed_c(const char* filename, const char* symbol, bool use_base85_encoding, bool use_compression)$/;"	f
bottom_y	stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon20
c_str	imgui.h	/^    const char*         c_str() const { return Buf.Data; }$/;"	f	struct:ImGuiTextBuffer
cam_inc	render2d.cpp	/^GLfloat cam_inc = 3;$/;"	v
cam_inc	render3d.cpp	/^GLfloat cam_inc = 3;$/;"	v
cam_inc2	render2d.cpp	/^GLfloat cam_inc2 = 0;$/;"	v
cam_inc2	render3d.cpp	/^GLfloat cam_inc2 = 0;$/;"	v
camera_pos	app_state_and_events.h	/^    std::array<GLfloat, 3> camera_pos[3], camera_target[3];$/;"	m	class:AppStateAndEvents
camera_target	app_state_and_events.h	/^    std::array<GLfloat, 3> camera_pos[3], camera_target[3];$/;"	m	class:AppStateAndEvents
capacity	imgui.h	/^    inline int                  capacity() const                { return Capacity; }$/;"	f	class:ImVector
cdata	stb_truetype.h	/^stbtt_bakedchar cdata[96]; \/\/ ASCII 32..126 is 95 glyphs$/;"	v
char_storage	stb_textedit.h	/^   short           char_storage;$/;"	m	struct:__anon1
chardata_for_range	stb_truetype.h	/^   stbtt_packedchar *chardata_for_range; \/\/ output$/;"	m	struct:__anon9
clear	imgui.h	/^    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }$/;"	f	class:ImVector
clear	imgui.h	/^    void                clear() { Buf.clear(); Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer
col	imgui.h	/^    ImU32   col;$/;"	m	struct:ImDrawVert
const_iterator	imgui.h	/^    typedef const value_type*   const_iterator;$/;"	t	class:ImVector
cursor	stb_textedit.h	/^   int cursor;$/;"	m	struct:__anon3
cursor_at_end_of_line	stb_textedit.h	/^   unsigned char cursor_at_end_of_line; \/\/ not implemented yet$/;"	m	struct:__anon3
cx	stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon11
cy	stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon11
data	stb_truetype.h	/^   unsigned char  * data;              \/\/ pointer to .ttf file$/;"	m	struct:stbtt_fontinfo
delete_length	stb_textedit.h	/^   short           delete_length;$/;"	m	struct:__anon1
direction	stb_truetype.h	/^   float direction;$/;"	m	struct:stbtt__active_edge
direction	stb_truetype.h	/^   int direction;$/;"	m	struct:stbtt__active_edge
drawCube	render2d.cpp	/^static void drawCube(float orientation[3], float position[3], float scale[3], float tone) {$/;"	f	file:
drawCube	render3d.cpp	/^static void drawCube(float orientation[3], float position[3], float scale[3], float tone) {$/;"	f	file:
drawSphere	render2d.cpp	/^static void drawSphere(double r, int lats, int longs, int x, int y, int z){$/;"	f	file:
drawSphere	render3d.cpp	/^static void drawSphere(double r, int lats, int longs, int x, int y, int z){$/;"	f	file:
dx	stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge
e	imgui.h	/^        const char* e;$/;"	m	struct:ImGuiTextFilter::TextRange
empty	imgui.h	/^        bool empty() const { return b == e; }$/;"	f	struct:ImGuiTextFilter::TextRange
empty	imgui.h	/^    bool                empty() { return Buf.Size <= 1; }$/;"	f	struct:ImGuiTextBuffer
empty	imgui.h	/^    inline bool                 empty() const                   { return Size == 0; }$/;"	f	class:ImVector
end	imgui.h	/^        const char* end() const { return e; }$/;"	f	struct:ImGuiTextFilter::TextRange
end	imgui.h	/^    const char*         end() const { return &Buf.back(); }      \/\/ Buf is zero-terminated, so end() will point on the zero-terminator$/;"	f	struct:ImGuiTextBuffer
end	imgui.h	/^    inline const_iterator       end() const                     { return Data + Size; }$/;"	f	class:ImVector
end	imgui.h	/^    inline iterator             end()                           { return Data + Size; }$/;"	f	class:ImVector
erase	imgui.h	/^    inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }$/;"	f	class:ImVector
error_callback	sdl_main.cpp	/^static void error_callback(int error, const char* description) {$/;"	f	file:
event	app_state_and_events.h	/^    SDL_Event event;$/;"	m	class:AppStateAndEvents
event	event.cpp	/^bool event(AppStateAndEvents &ae) {$/;"	f
extra	stb_rect_pack.h	/^   stbrp_node extra[2]; \/\/ we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'$/;"	m	struct:stbrp_context
ey	stb_truetype.h	/^   float ey;$/;"	m	struct:stbtt__active_edge
faces_count	palace.h	/^unsigned int faces_count[]={110, 38, 1190, 1190, 1190, 1190, 110, 110, 550, 110, 110, 110, 110, 1190, 1190, 1190, 1190, 943, 440};$/;"	v
faces_count	untitled.h	/^unsigned int faces_count[]={834, 834, 834, 834, 2, 834, 834};$/;"	v
fdx	stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
fdy	stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
first_char	stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon5
first_free	stb_truetype.h	/^   void   *first_free;$/;"	m	struct:stbtt__hheap
first_unicode_codepoint_in_range	stb_truetype.h	/^   int first_unicode_codepoint_in_range;  \/\/ if non-zero, then the chars are continuous, and this is the first codepoint$/;"	m	struct:__anon9
font_size	stb_truetype.h	/^   float font_size;$/;"	m	struct:__anon9
fontstart	stb_truetype.h	/^   int              fontstart;         \/\/ offset of start of font$/;"	m	struct:stbtt_fontinfo
free_head	stb_rect_pack.h	/^   stbrp_node *free_head;$/;"	m	struct:stbrp_context
front	imgui.h	/^        char front() const { return *b; }$/;"	f	struct:ImGuiTextFilter::TextRange
front	imgui.h	/^    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector
front	imgui.h	/^    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector
ftex	stb_truetype.h	/^GLuint ftex;$/;"	v
fx	stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
g_FontTexture	imgui_impl_sdl.cpp	/^static GLuint       g_FontTexture = 0;$/;"	v	file:
g_MousePressed	imgui_impl_sdl.cpp	/^static bool         g_MousePressed[3] = { false, false, false };$/;"	v	file:
g_MouseWheel	imgui_impl_sdl.cpp	/^static float        g_MouseWheel = 0.0f;$/;"	v	file:
g_Time	imgui_impl_sdl.cpp	/^static double       g_Time = 0.0f;$/;"	v	file:
getCameraPos	app_state_and_events.cpp	/^std::array<GLfloat, 3>& AppStateAndEvents::getCameraPos() {$/;"	f	class:AppStateAndEvents
getCameraTarget	app_state_and_events.cpp	/^std::array<GLfloat, 3>& AppStateAndEvents::getCameraTarget() {$/;"	f	class:AppStateAndEvents
getEvent	app_state_and_events.cpp	/^SDL_Event &AppStateAndEvents::getEvent() {$/;"	f	class:AppStateAndEvents
getMouseToCamera	app_state_and_events.cpp	/^bool AppStateAndEvents::getMouseToCamera() {$/;"	f	class:AppStateAndEvents
glyf	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
h	stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect
h	stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
h	stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon12
h_oversample	stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon9
h_oversample	stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context
has_preferred_x	stb_textedit.h	/^   unsigned char has_preferred_x;$/;"	m	struct:__anon3
head	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
head	stb_truetype.h	/^   struct stbtt__hheap_chunk *head;$/;"	m	struct:stbtt__hheap	typeref:struct:stbtt__hheap::stbtt__hheap_chunk
height	stb_rect_pack.h	/^   int height;$/;"	m	struct:stbrp_context
height	stb_textedit.h	/^   float height; \/\/ height of line$/;"	m	struct:__anon5
height	stb_truetype.h	/^   int   height;$/;"	m	struct:stbtt_pack_context
height	stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon20
heuristic	stb_rect_pack.h	/^   int heuristic;$/;"	m	struct:stbrp_context
hhea	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
hmtx	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
id	stb_rect_pack.h	/^   int            id;$/;"	m	struct:stbrp_rect
id	stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
indexToLocFormat	stb_truetype.h	/^   int indexToLocFormat;              \/\/ format needed to map from glyph index to glyph$/;"	m	struct:stbtt_fontinfo
index_map	stb_truetype.h	/^   int index_map;                     \/\/ a cmap mapping for our chosen character encoding$/;"	m	struct:stbtt_fontinfo
indexes	palace.h	/^unsigned short indexes[]={$/;"	v
indexes	untitled.h	/^unsigned short indexes[]={$/;"	v
indices_offset_table	palace.h	/^unsigned int indices_offset_table []={$/;"	v
indices_offset_table	untitled.h	/^unsigned int indices_offset_table []={$/;"	v
init_mode	stb_rect_pack.h	/^   int init_mode;$/;"	m	struct:stbrp_context
init_render	render3d.cpp	/^void init_render() {$/;"	f
init_render2d	render2d.cpp	/^void init_render2d() {$/;"	f
initialized	stb_textedit.h	/^   unsigned char initialized;$/;"	m	struct:__anon3
insert	imgui.h	/^    inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }$/;"	f	class:ImVector
insert_length	stb_textedit.h	/^   short           insert_length;$/;"	m	struct:__anon1
insert_mode	stb_textedit.h	/^   unsigned char insert_mode;$/;"	m	struct:__anon3
invert	stb_truetype.h	/^   int invert;$/;"	m	struct:stbtt__edge
isOutdoor	app_state_and_events.cpp	/^bool AppStateAndEvents::isOutdoor() {$/;"	f	class:AppStateAndEvents
is_blank	imgui.h	/^        static bool is_blank(char c) { return c == ' ' || c == '\\t'; }$/;"	f	struct:ImGuiTextFilter::TextRange
is_separator	imgui.cpp	/^static bool is_separator(unsigned int c)                                        { return ImCharIsSpace(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }$/;"	f	namespace:ImGuiStb
is_word_boundary	stb_textedit.h	/^static int is_word_boundary( STB_TEXTEDIT_STRING *_str, int _idx )$/;"	f
is_word_boundary_from_left	imgui.cpp	/^static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->Text[idx-1] ) && is_separator( obj->Text[idx] ) ) : 1; }$/;"	f	namespace:ImGuiStb
is_word_boundary_from_right	imgui.cpp	/^static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->Text[idx-1] ) && !is_separator( obj->Text[idx] ) ) : 1; }$/;"	f	namespace:ImGuiStb
iterator	imgui.h	/^    typedef value_type*         iterator;$/;"	t	class:ImVector
kern	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
key	imgui.h	/^        ImGuiID key;$/;"	m	struct:ImGuiStorage::Pair
length	stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon5
loca	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
lpwin	render2d.cpp	/^SDL_Window *lpwin = NULL;$/;"	v
lpwin	render3d.cpp	/^SDL_Window *lpwin = NULL;$/;"	v
main	extra_fonts/binary_to_compressed_c.cpp	/^int main(int argc, char** argv)$/;"	f
main	sdl_main.cpp	/^int main(int ac, char *av[])$/;"	f
main	stb_truetype.h	/^int main(int argc, char **argv)$/;"	f
my_stbtt_initfont	stb_truetype.h	/^void my_stbtt_initfont(void)$/;"	f
my_stbtt_print	stb_truetype.h	/^void my_stbtt_print(float x, float y, char *text)$/;"	f
next	stb_rect_pack.h	/^   stbrp_node  *next;$/;"	m	struct:stbrp_node
next	stb_truetype.h	/^   struct stbtt__active_edge *next;$/;"	m	struct:stbtt__active_edge	typeref:struct:stbtt__active_edge::stbtt__active_edge
next	stb_truetype.h	/^   struct stbtt__hheap_chunk *next;$/;"	m	struct:stbtt__hheap_chunk	typeref:struct:stbtt__hheap_chunk::stbtt__hheap_chunk
nodes	stb_truetype.h	/^   void  *nodes;$/;"	m	struct:stbtt_pack_context
numGlyphs	stb_truetype.h	/^   int numGlyphs;                     \/\/ number of glyphs, needed for range checking$/;"	m	struct:stbtt_fontinfo
num_chars	stb_textedit.h	/^   int num_chars;$/;"	m	struct:__anon4
num_chars	stb_truetype.h	/^   int num_chars;$/;"	m	struct:__anon9
num_nodes	stb_rect_pack.h	/^   int num_nodes;$/;"	m	struct:stbrp_context
num_remaining_in_head_chunk	stb_truetype.h	/^   int    num_remaining_in_head_chunk;$/;"	m	struct:stbtt__hheap
nx	palace.h	/^	float nx,ny,nz;$/;"	m	struct:vertex_struct
nx	untitled.h	/^	float nx,ny,nz;$/;"	m	struct:vertex_struct
ny	palace.h	/^	float nx,ny,nz;$/;"	m	struct:vertex_struct
ny	untitled.h	/^	float nx,ny,nz;$/;"	m	struct:vertex_struct
nz	palace.h	/^	float nx,ny,nz;$/;"	m	struct:vertex_struct
nz	untitled.h	/^	float nx,ny,nz;$/;"	m	struct:vertex_struct
open_control	ui.cpp	/^static bool open_control = false;$/;"	v	file:
open_goals	ui.cpp	/^static bool open_goals = false;$/;"	v	file:
open_help	ui.cpp	/^static bool open_help = false;$/;"	v	file:
open_modeler	ui.cpp	/^static bool open_modeler = false;$/;"	v	file:
operator *	imgui_internal.h	/^static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }$/;"	f
operator *	imgui_internal.h	/^static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }$/;"	f
operator *=	imgui_internal.h	/^static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }$/;"	f
operator +	imgui_internal.h	/^static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }$/;"	f
operator +=	imgui_internal.h	/^static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }$/;"	f
operator -	imgui_internal.h	/^static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }$/;"	f
operator -	imgui_internal.h	/^static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }$/;"	f
operator -=	imgui_internal.h	/^static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }$/;"	f
operator /	imgui_internal.h	/^static inline ImVec2 operator\/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x\/rhs.x, lhs.y\/rhs.y); }$/;"	f
operator /	imgui_internal.h	/^static inline ImVec2 operator\/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x\/rhs, lhs.y\/rhs); }$/;"	f
operator /=	imgui_internal.h	/^static inline ImVec2& operator\/=(ImVec2& lhs, const float rhs)                  { lhs.x \/= rhs; lhs.y \/= rhs; return lhs; }$/;"	f
operator ImU32	imgui.h	/^    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }$/;"	f	struct:ImColor
operator ImVec4	imgui.h	/^    inline operator ImVec4() const                                  { return Value; }$/;"	f	struct:ImColor
operator []	imgui.h	/^    inline char         operator[](int i) { return Buf.Data[i]; }$/;"	f	struct:ImGuiTextBuffer
operator []	imgui.h	/^    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector
operator []	imgui.h	/^    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector
operator bool	imgui.h	/^    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }$/;"	f	struct:ImGuiOnceUponAFrame
operator delete	imgui_internal.h	/^inline void operator delete(void*, ImPlacementNewDummy, void*) {}$/;"	f
operator new	imgui_internal.h	/^inline void* operator new(size_t, ImPlacementNewDummy, void* ptr) { return ptr; }$/;"	f
outdoor	app_state_and_events.h	/^    bool outdoor;$/;"	m	class:AppStateAndEvents
outliterals	extra_fonts/binary_to_compressed_c.cpp	/^static void outliterals(stb_uchar *in, int numlit)$/;"	f	file:
pack_info	stb_truetype.h	/^   void *pack_info;$/;"	m	struct:stbtt_pack_context
padding	stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon11
padding	stb_truetype.h	/^   int   padding;$/;"	m	struct:stbtt_pack_context
padding1	stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon3
padding2	stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon3
padding3	stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon3
pause	render2d.cpp	/^bool pause = true;$/;"	v
pause	render3d.cpp	/^bool pause = true;$/;"	v
pixels	stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:__anon12
pixels	stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:stbtt_pack_context
pop_back	imgui.h	/^    inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }$/;"	f	class:ImVector
pos	imgui.h	/^    ImVec2  pos;$/;"	m	struct:ImDrawVert
preferred_x	stb_textedit.h	/^   float preferred_x; \/\/ this determines where the cursor up\/down tries to seek to along x$/;"	m	struct:__anon3
prev_first	stb_textedit.h	/^   int prev_first;  \/\/ first char of previous row$/;"	m	struct:__anon5
prev_link	stb_rect_pack.h	/^   stbrp_node **prev_link;$/;"	m	struct:__anon24
proggy_clean_ttf_compressed_data_base85	imgui_draw.cpp	/^static const char proggy_clean_ttf_compressed_data_base85[11980+1] =$/;"	v	file:
push_back	imgui.h	/^    inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }$/;"	f	class:ImVector
rect_height_compare	stb_rect_pack.h	/^static int rect_height_compare(const void *a, const void *b)$/;"	f
rect_original_order	stb_rect_pack.h	/^static int rect_original_order(const void *a, const void *b)$/;"	f
rect_width_compare	stb_rect_pack.h	/^static int rect_width_compare(const void *a, const void *b)$/;"	f
redo_char_point	stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon2
redo_point	stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon2
render	render3d.cpp	/^void render(SDL_Window *win, AppStateAndEvents &ae) {$/;"	f
render2d	render2d.cpp	/^void render2d(SDL_Window *win, AppStateAndEvents &ae) {$/;"	f
reserve	imgui.h	/^    inline void                 reserve(int new_capacity)$/;"	f	class:ImVector
resetIndoorView	app_state_and_events.cpp	/^void AppStateAndEvents::resetIndoorView() {$/;"	f	class:AppStateAndEvents
resetOutdoorView	app_state_and_events.cpp	/^void AppStateAndEvents::resetOutdoorView() {$/;"	f	class:AppStateAndEvents
resize	imgui.h	/^    inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }$/;"	f	class:ImVector
rotateCube	render2d.cpp	/^float rotateCube = 0; \/\/ Apply rotation on cube$/;"	v
rotateCube	render3d.cpp	/^float rotateCube = 0; \/\/ Apply rotation on cube$/;"	v
rotateSpeed	render2d.cpp	/^float rotateSpeed = 180.0f; \/* degrees per second *\/$/;"	v
rotateSpeed	render3d.cpp	/^float rotateSpeed = 180.0f; \/* degrees per second *\/$/;"	v
s0	stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon7
s1	stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon7
select_end	stb_textedit.h	/^   int select_end;$/;"	m	struct:__anon3
select_start	stb_textedit.h	/^   int select_start;          \/\/ selection start point$/;"	m	struct:__anon3
setCameraPos	app_state_and_events.cpp	/^void AppStateAndEvents::setCameraPos(std::array<GLfloat, 3> &f) {$/;"	f	class:AppStateAndEvents
setCameraTarget	app_state_and_events.cpp	/^void AppStateAndEvents::setCameraTarget(std::array<GLfloat, 3> &f) {$/;"	f	class:AppStateAndEvents
setIsOutdoor	app_state_and_events.cpp	/^void AppStateAndEvents::setIsOutdoor(bool b) {$/;"	f	class:AppStateAndEvents
setMouseToCamera	app_state_and_events.cpp	/^void AppStateAndEvents::setMouseToCamera(bool b) {$/;"	f	class:AppStateAndEvents
single_line	stb_textedit.h	/^   unsigned char single_line;$/;"	m	struct:__anon3
size	imgui.h	/^    inline int                  size() const                    { return Size; }$/;"	f	class:ImVector
size	imgui.h	/^    int                 size() const { return Buf.Size - 1; }$/;"	f	struct:ImGuiTextBuffer
snprintf	imgui.cpp	593;"	d	file:
snprintf	imgui_demo.cpp	25;"	d	file:
snprintf	imgui_draw.cpp	32;"	d	file:
split	imgui.cpp	/^void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>& out)$/;"	f	class:ImGuiTextFilter::TextRange
stb__barrier	imgui_draw.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier2	imgui_draw.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier3	imgui_draw.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier4	imgui_draw.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__dout	imgui_draw.cpp	/^static unsigned char *stb__dout;$/;"	v	file:
stb__hashsize	extra_fonts/binary_to_compressed_c.cpp	/^static  stb_uint stb__hashsize = 32768;$/;"	v	file:
stb__hc	extra_fonts/binary_to_compressed_c.cpp	214;"	d	file:
stb__hc2	extra_fonts/binary_to_compressed_c.cpp	215;"	d	file:
stb__hc3	extra_fonts/binary_to_compressed_c.cpp	216;"	d	file:
stb__in2	imgui_draw.cpp	2114;"	d	file:
stb__in3	imgui_draw.cpp	2115;"	d	file:
stb__in4	imgui_draw.cpp	2116;"	d	file:
stb__lit	imgui_draw.cpp	/^static void stb__lit(unsigned char *data, unsigned int length)$/;"	f	file:
stb__match	imgui_draw.cpp	/^static void stb__match(unsigned char *data, unsigned int length)$/;"	f	file:
stb__nc	extra_fonts/binary_to_compressed_c.cpp	250;"	d	file:
stb__out	extra_fonts/binary_to_compressed_c.cpp	/^static stb_uchar *stb__out;$/;"	v	file:
stb__outbytes	extra_fonts/binary_to_compressed_c.cpp	/^static stb_uint   stb__outbytes;$/;"	v	file:
stb__outfile	extra_fonts/binary_to_compressed_c.cpp	/^static FILE      *stb__outfile;$/;"	v	file:
stb__running_adler	extra_fonts/binary_to_compressed_c.cpp	/^static unsigned int stb__running_adler;$/;"	v	file:
stb__window	extra_fonts/binary_to_compressed_c.cpp	/^static int stb__window = 0x40000; \/\/ 256K$/;"	v	file:
stb__write	extra_fonts/binary_to_compressed_c.cpp	/^static void stb__write(unsigned char v)$/;"	f	file:
stb_adler32	extra_fonts/binary_to_compressed_c.cpp	/^static stb_uint stb_adler32(stb_uint adler32, stb_uchar *buffer, stb_uint buflen)$/;"	f	file:
stb_adler32	imgui_draw.cpp	/^static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)$/;"	f	file:
stb_compress	extra_fonts/binary_to_compressed_c.cpp	/^stb_uint stb_compress(stb_uchar *out, stb_uchar *input, stb_uint length)$/;"	f
stb_compress_chunk	extra_fonts/binary_to_compressed_c.cpp	/^static int stb_compress_chunk(stb_uchar *history,$/;"	f	file:
stb_compress_inner	extra_fonts/binary_to_compressed_c.cpp	/^static int stb_compress_inner(stb_uchar *input, stb_uint length)$/;"	f	file:
stb_decompress	imgui_draw.cpp	/^static unsigned int stb_decompress(unsigned char *output, unsigned char *i, unsigned int length)$/;"	f	file:
stb_decompress_length	imgui_draw.cpp	/^static unsigned int stb_decompress_length(unsigned char *input)$/;"	f	file:
stb_decompress_token	imgui_draw.cpp	/^static unsigned char *stb_decompress_token(unsigned char *i)$/;"	f	file:
stb_matchlen	extra_fonts/binary_to_compressed_c.cpp	/^static unsigned int stb_matchlen(stb_uchar *m1, stb_uchar *m2, stb_uint maxlen)$/;"	f	file:
stb_not_crap	extra_fonts/binary_to_compressed_c.cpp	/^static int stb_not_crap(int best, int dist)$/;"	f	file:
stb_out	extra_fonts/binary_to_compressed_c.cpp	169;"	d	file:
stb_out2	extra_fonts/binary_to_compressed_c.cpp	/^static void stb_out2(stb_uint v)$/;"	f	file:
stb_out3	extra_fonts/binary_to_compressed_c.cpp	/^static void stb_out3(stb_uint v) { stb_out(v >> 16); stb_out(v >> 8); stb_out(v); }$/;"	f	file:
stb_out4	extra_fonts/binary_to_compressed_c.cpp	/^static void stb_out4(stb_uint v) { stb_out(v >> 24); stb_out(v >> 16);$/;"	f	file:
stb_text_create_undo_record	stb_textedit.h	/^static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)$/;"	f
stb_text_createundo	stb_textedit.h	/^static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)$/;"	f
stb_text_locate_coord	stb_textedit.h	/^static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)$/;"	f
stb_text_makeundo_delete	stb_textedit.h	/^static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)$/;"	f
stb_text_makeundo_insert	stb_textedit.h	/^static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)$/;"	f
stb_text_makeundo_replace	stb_textedit.h	/^static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)$/;"	f
stb_text_redo	stb_textedit.h	/^static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_text_undo	stb_textedit.h	/^static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_clamp	stb_textedit.h	/^static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_clear_state	stb_textedit.h	/^static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)$/;"	f
stb_textedit_click	stb_textedit.h	/^static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f
stb_textedit_cut	stb_textedit.h	/^static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_delete	stb_textedit.h	/^static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)$/;"	f
stb_textedit_delete_selection	stb_textedit.h	/^static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_discard_redo	stb_textedit.h	/^static void stb_textedit_discard_redo(StbUndoState *state)$/;"	f
stb_textedit_discard_undo	stb_textedit.h	/^static void stb_textedit_discard_undo(StbUndoState *state)$/;"	f
stb_textedit_drag	stb_textedit.h	/^static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f
stb_textedit_find_charpos	stb_textedit.h	/^static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)$/;"	f
stb_textedit_flush_redo	stb_textedit.h	/^static void stb_textedit_flush_redo(StbUndoState *state)$/;"	f
stb_textedit_initialize_state	stb_textedit.h	/^static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)$/;"	f
stb_textedit_key	stb_textedit.h	/^static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int key)$/;"	f
stb_textedit_move_to_first	stb_textedit.h	/^static void stb_textedit_move_to_first(STB_TexteditState *state)$/;"	f
stb_textedit_move_to_last	stb_textedit.h	/^static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_move_to_word_next	stb_textedit.h	/^static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *_str, int c )$/;"	f
stb_textedit_move_to_word_previous	stb_textedit.h	/^static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *_str, int c )$/;"	f
stb_textedit_paste	stb_textedit.h	/^static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)$/;"	f
stb_textedit_prep_selection_at_cursor	stb_textedit.h	/^static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)$/;"	f
stb_textedit_sortselection	stb_textedit.h	/^static void stb_textedit_sortselection(STB_TexteditState *state)$/;"	f
stb_uchar	extra_fonts/binary_to_compressed_c.cpp	/^typedef unsigned char stb_uchar;$/;"	t	file:
stb_uint	extra_fonts/binary_to_compressed_c.cpp	/^typedef unsigned int stb_uint;$/;"	t	file:
stbrp__findresult	stb_rect_pack.h	/^} stbrp__findresult;$/;"	t	typeref:struct:__anon24
stbrp__skyline_find_best_pos	stb_rect_pack.h	/^static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)$/;"	f
stbrp__skyline_find_min_y	stb_rect_pack.h	/^static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)$/;"	f
stbrp__skyline_pack_rectangle	stb_rect_pack.h	/^static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)$/;"	f
stbrp_context	stb_rect_pack.h	/^struct stbrp_context$/;"	s
stbrp_context	stb_rect_pack.h	/^typedef struct stbrp_context stbrp_context;$/;"	t	typeref:struct:stbrp_context
stbrp_context	stb_truetype.h	/^} stbrp_context;$/;"	t	typeref:struct:__anon20
stbrp_coord	stb_rect_pack.h	/^typedef int            stbrp_coord;$/;"	t
stbrp_coord	stb_rect_pack.h	/^typedef unsigned short stbrp_coord;$/;"	t
stbrp_coord	stb_truetype.h	/^typedef int stbrp_coord;$/;"	t
stbrp_init_target	stb_rect_pack.h	/^STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)$/;"	f
stbrp_init_target	stb_truetype.h	/^static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)$/;"	f
stbrp_node	stb_rect_pack.h	/^struct stbrp_node$/;"	s
stbrp_node	stb_rect_pack.h	/^typedef struct stbrp_node    stbrp_node;$/;"	t	typeref:struct:stbrp_node
stbrp_node	stb_truetype.h	/^} stbrp_node;$/;"	t	typeref:struct:__anon21
stbrp_pack_rects	stb_rect_pack.h	/^STBRP_DEF void stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)$/;"	f
stbrp_pack_rects	stb_truetype.h	/^static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)$/;"	f
stbrp_rect	stb_rect_pack.h	/^struct stbrp_rect$/;"	s
stbrp_rect	stb_rect_pack.h	/^typedef struct stbrp_rect    stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_rect	stb_truetype.h	/^struct stbrp_rect$/;"	s
stbrp_rect	stb_truetype.h	/^typedef struct stbrp_rect stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_setup_allow_out_of_mem	stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)$/;"	f
stbrp_setup_heuristic	stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)$/;"	f
stbtt_BakeFontBitmap	stb_truetype.h	/^STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  \/\/ font location (use offset=0 for plain .ttf)$/;"	f
stbtt_CompareUTF8toUTF16_bigendian	stb_truetype.h	/^STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2) $/;"	f
stbtt_FindGlyphIndex	stb_truetype.h	/^STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)$/;"	f
stbtt_FindMatchingFont	stb_truetype.h	/^STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *font_collection, const char *name_utf8, stbtt_int32 flags)$/;"	f
stbtt_FlattenCurves	stb_truetype.h	/^static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)$/;"	f
stbtt_FreeBitmap	stb_truetype.h	/^STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)$/;"	f
stbtt_FreeShape	stb_truetype.h	/^STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)$/;"	f
stbtt_GetBakedQuad	stb_truetype.h	/^STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)$/;"	f
stbtt_GetCodepointBitmap	stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointBitmapBox	stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetCodepointBitmapBoxSubpixel	stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetCodepointBitmapSubpixel	stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointBox	stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetCodepointHMetrics	stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)$/;"	f
stbtt_GetCodepointKernAdvance	stb_truetype.h	/^STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)$/;"	f
stbtt_GetCodepointShape	stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)$/;"	f
stbtt_GetFontBoundingBox	stb_truetype.h	/^STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetFontNameString	stb_truetype.h	/^STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)$/;"	f
stbtt_GetFontOffsetForIndex	stb_truetype.h	/^STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *font_collection, int index)$/;"	f
stbtt_GetFontVMetrics	stb_truetype.h	/^STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)$/;"	f
stbtt_GetGlyphBitmap	stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphBitmapBox	stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetGlyphBitmapBoxSubpixel	stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetGlyphBitmapSubpixel	stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphBox	stb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetGlyphHMetrics	stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)$/;"	f
stbtt_GetGlyphKernAdvance	stb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)$/;"	f
stbtt_GetGlyphShape	stb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f
stbtt_GetPackedQuad	stb_truetype.h	/^STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)$/;"	f
stbtt_InitFont	stb_truetype.h	/^STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data2, int fontstart)$/;"	f
stbtt_IsGlyphEmpty	stb_truetype.h	/^STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt_MakeCodepointBitmap	stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)$/;"	f
stbtt_MakeCodepointBitmapSubpixel	stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)$/;"	f
stbtt_MakeGlyphBitmap	stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)$/;"	f
stbtt_MakeGlyphBitmapSubpixel	stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)$/;"	f
stbtt_PackBegin	stb_truetype.h	/^STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)$/;"	f
stbtt_PackEnd	stb_truetype.h	/^STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)$/;"	f
stbtt_PackFontRange	stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size,$/;"	f
stbtt_PackFontRanges	stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)$/;"	f
stbtt_PackFontRangesGatherRects	stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f
stbtt_PackFontRangesPackRects	stb_truetype.h	/^STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)$/;"	f
stbtt_PackFontRangesRenderIntoRects	stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f
stbtt_PackSetOversampling	stb_truetype.h	/^STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)$/;"	f
stbtt_Rasterize	stb_truetype.h	/^STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)$/;"	f
stbtt_ScaleForMappingEmToPixels	stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)$/;"	f
stbtt_ScaleForPixelHeight	stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)$/;"	f
stbtt__CompareUTF8toUTF16_bigendian_prefix	stb_truetype.h	/^static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(const stbtt_uint8 *s1, stbtt_int32 len1, const stbtt_uint8 *s2, stbtt_int32 len2) $/;"	f
stbtt__GetGlyfOffset	stb_truetype.h	/^static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt__active_edge	stb_truetype.h	/^typedef struct stbtt__active_edge$/;"	s
stbtt__active_edge	stb_truetype.h	/^} stbtt__active_edge;$/;"	t	typeref:struct:stbtt__active_edge
stbtt__add_point	stb_truetype.h	/^static void stbtt__add_point(stbtt__point *points, int n, float x, float y)$/;"	f
stbtt__bitmap	stb_truetype.h	/^} stbtt__bitmap;$/;"	t	typeref:struct:__anon12
stbtt__check_size16	stb_truetype.h	/^   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];$/;"	t
stbtt__check_size32	stb_truetype.h	/^   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];$/;"	t
stbtt__close_shape	stb_truetype.h	/^static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,$/;"	f
stbtt__edge	stb_truetype.h	/^typedef struct stbtt__edge {$/;"	s
stbtt__edge	stb_truetype.h	/^} stbtt__edge;$/;"	t	typeref:struct:stbtt__edge
stbtt__fill_active_edges	stb_truetype.h	/^static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)$/;"	f
stbtt__fill_active_edges_new	stb_truetype.h	/^static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)$/;"	f
stbtt__find_table	stb_truetype.h	/^static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)$/;"	f
stbtt__h_prefilter	stb_truetype.h	/^static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f
stbtt__handle_clipped_edge	stb_truetype.h	/^static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)$/;"	f
stbtt__hheap	stb_truetype.h	/^typedef struct stbtt__hheap$/;"	s
stbtt__hheap	stb_truetype.h	/^} stbtt__hheap;$/;"	t	typeref:struct:stbtt__hheap
stbtt__hheap_alloc	stb_truetype.h	/^static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)$/;"	f
stbtt__hheap_chunk	stb_truetype.h	/^typedef struct stbtt__hheap_chunk$/;"	s
stbtt__hheap_chunk	stb_truetype.h	/^} stbtt__hheap_chunk;$/;"	t	typeref:struct:stbtt__hheap_chunk
stbtt__hheap_cleanup	stb_truetype.h	/^static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)$/;"	f
stbtt__hheap_free	stb_truetype.h	/^static void stbtt__hheap_free(stbtt__hheap *hh, void *p)$/;"	f
stbtt__isfont	stb_truetype.h	/^static int stbtt__isfont(const stbtt_uint8 *font)$/;"	f
stbtt__matches	stb_truetype.h	/^static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)$/;"	f
stbtt__matchpair	stb_truetype.h	/^static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)$/;"	f
stbtt__new_active	stb_truetype.h	/^static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)$/;"	f
stbtt__oversample_shift	stb_truetype.h	/^static float stbtt__oversample_shift(int oversample)$/;"	f
stbtt__point	stb_truetype.h	/^} stbtt__point;$/;"	t	typeref:struct:__anon19
stbtt__rasterize	stb_truetype.h	/^static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)$/;"	f
stbtt__rasterize_sorted_edges	stb_truetype.h	/^static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)$/;"	f
stbtt__sort_edges	stb_truetype.h	/^static void stbtt__sort_edges(stbtt__edge *p, int n)$/;"	f
stbtt__sort_edges_ins_sort	stb_truetype.h	/^static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)$/;"	f
stbtt__sort_edges_quicksort	stb_truetype.h	/^static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)$/;"	f
stbtt__tesselate_curve	stb_truetype.h	/^static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)$/;"	f
stbtt__test_oversample_pow2	stb_truetype.h	/^typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];$/;"	t
stbtt__v_prefilter	stb_truetype.h	/^static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f
stbtt_aligned_quad	stb_truetype.h	/^} stbtt_aligned_quad;$/;"	t	typeref:struct:__anon7
stbtt_bakedchar	stb_truetype.h	/^} stbtt_bakedchar;$/;"	t	typeref:struct:__anon6
stbtt_fontinfo	stb_truetype.h	/^struct stbtt_fontinfo$/;"	s
stbtt_fontinfo	stb_truetype.h	/^typedef struct stbtt_fontinfo stbtt_fontinfo;$/;"	t	typeref:struct:stbtt_fontinfo
stbtt_int16	stb_truetype.h	/^   typedef signed   short  stbtt_int16;$/;"	t
stbtt_int32	stb_truetype.h	/^   typedef signed   int    stbtt_int32;$/;"	t
stbtt_int8	stb_truetype.h	/^   typedef signed   char   stbtt_int8;$/;"	t
stbtt_pack_context	stb_truetype.h	/^struct stbtt_pack_context {$/;"	s
stbtt_pack_context	stb_truetype.h	/^typedef struct stbtt_pack_context stbtt_pack_context;$/;"	t	typeref:struct:stbtt_pack_context
stbtt_pack_range	stb_truetype.h	/^} stbtt_pack_range;$/;"	t	typeref:struct:__anon9
stbtt_packedchar	stb_truetype.h	/^} stbtt_packedchar;$/;"	t	typeref:struct:__anon8
stbtt_setvertex	stb_truetype.h	/^static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)$/;"	f
stbtt_tag	stb_truetype.h	981;"	d
stbtt_tag4	stb_truetype.h	980;"	d
stbtt_uint16	stb_truetype.h	/^   typedef unsigned short  stbtt_uint16;$/;"	t
stbtt_uint32	stb_truetype.h	/^   typedef unsigned int    stbtt_uint32;$/;"	t
stbtt_uint8	stb_truetype.h	/^   typedef unsigned char   stbtt_uint8;$/;"	t
stbtt_vertex	stb_truetype.h	/^   } stbtt_vertex;$/;"	t	typeref:struct:__anon11
stbtt_vertex_type	stb_truetype.h	733;"	d
stride	stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon12
stride_in_bytes	stb_truetype.h	/^   int   stride_in_bytes;$/;"	m	struct:stbtt_pack_context
swap	imgui.h	/^    inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }$/;"	f	class:ImVector
sy	stb_truetype.h	/^   float sy;$/;"	m	struct:stbtt__active_edge
t	render2d.cpp	/^float t, T = 0.0;$/;"	v
t	render3d.cpp	/^float t, T = 0.0;$/;"	v
t0	stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon7
t1	stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon7
temp_bitmap	stb_truetype.h	/^unsigned char temp_bitmap[512*512];$/;"	v
transformations	palace.h	/^float transformations[][16]={$/;"	v
transformations	untitled.h	/^float transformations[][16]={$/;"	v
trim_blanks	imgui.h	/^        void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }$/;"	f	struct:ImGuiTextFilter::TextRange
ttBYTE	stb_truetype.h	960;"	d
ttCHAR	stb_truetype.h	961;"	d
ttFixed	stb_truetype.h	962;"	d
ttLONG	stb_truetype.h	/^   static stbtt_int32 ttLONG(const stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f
ttLONG	stb_truetype.h	969;"	d
ttSHORT	stb_truetype.h	/^   static stbtt_int16 ttSHORT(const stbtt_uint8 *p)   { return p[0]*256 + p[1]; }$/;"	f
ttSHORT	stb_truetype.h	967;"	d
ttULONG	stb_truetype.h	/^   static stbtt_uint32 ttULONG(const stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f
ttULONG	stb_truetype.h	968;"	d
ttUSHORT	stb_truetype.h	/^   static stbtt_uint16 ttUSHORT(const stbtt_uint8 *p) { return p[0]*256 + p[1]; }$/;"	f
ttUSHORT	stb_truetype.h	966;"	d
ttf_buffer	stb_truetype.h	/^char ttf_buffer[1<<25];$/;"	v
ttf_buffer	stb_truetype.h	/^unsigned char ttf_buffer[1<<20];$/;"	v
type	stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon11
u	palace.h	/^	float u,v;$/;"	m	struct:vertex_struct
u	untitled.h	/^	float u,v;$/;"	m	struct:vertex_struct
ui	ui.cpp	/^void ui(AppStateAndEvents &ae) {$/;"	f
undo_char	stb_textedit.h	/^   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];$/;"	m	struct:__anon2
undo_char_point	stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon2
undo_point	stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon2
undo_rec	stb_textedit.h	/^   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];$/;"	m	struct:__anon2
undostate	stb_textedit.h	/^   StbUndoState undostate;$/;"	m	struct:__anon3
user_allocator_context	stb_truetype.h	/^   void *user_allocator_context;$/;"	m	struct:stbtt_pack_context
userdata	stb_truetype.h	/^   void           * userdata;$/;"	m	struct:stbtt_fontinfo
uv	imgui.h	/^    ImVec2  uv;$/;"	m	struct:ImDrawVert
v	palace.h	/^	float u,v;$/;"	m	struct:vertex_struct
v	untitled.h	/^	float u,v;$/;"	m	struct:vertex_struct
v_oversample	stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon9
v_oversample	stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context
va_copy	imgui.cpp	1488;"	d	file:
val_f	imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon25
val_i	imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon25
val_p	imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon25
value_type	imgui.h	/^    typedef T                   value_type;$/;"	t	class:ImVector
vbo	func.h	/^GLuint *vbo;$/;"	v
vertex_count	palace.h	/^unsigned int vertex_count[]={237, 54, 1605, 1605, 1605, 1605, 208, 208, 1207, 208, 208, 208, 208, 1605, 1605, 1605, 1605, 1140, 970};$/;"	v
vertex_count	untitled.h	/^unsigned int vertex_count[]={950, 950, 950, 950, 4, 950, 950};$/;"	v
vertex_offset_table	palace.h	/^unsigned int vertex_offset_table []={$/;"	v
vertex_offset_table	untitled.h	/^unsigned int vertex_offset_table []={$/;"	v
vertex_struct	palace.h	/^struct vertex_struct {$/;"	s
vertex_struct	untitled.h	/^struct vertex_struct {$/;"	s
vertices	palace.h	/^struct vertex_struct vertices[]={$/;"	v	typeref:struct:vertex_struct
vertices	untitled.h	/^struct vertex_struct vertices[]={$/;"	v	typeref:struct:vertex_struct
vinx	func.h	/^GLuint *vinx;$/;"	v
w	imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4
w	stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect
w	stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
w	stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon12
was_packed	stb_rect_pack.h	/^   int            was_packed;  \/\/ non-zero if valid packing$/;"	m	struct:stbrp_rect
was_packed	stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
where	stb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  where;$/;"	m	struct:__anon1
width	stb_rect_pack.h	/^   int width;$/;"	m	struct:stbrp_context
width	stb_truetype.h	/^   int   width;$/;"	m	struct:stbtt_pack_context
width	stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon20
windowheight	sdl_main.cpp	/^int windowheight;$/;"	v
windowwidth	sdl_main.cpp	/^int windowwidth;$/;"	v
x	imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4
x	imgui.h	/^    float x, y;$/;"	m	struct:ImVec2
x	palace.h	/^	float x,y,z;$/;"	m	struct:vertex_struct
x	stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon24
x	stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect
x	stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node
x	stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon5
x	stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon11
x	stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon19
x	stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge
x	stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon20
x	stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect
x	stb_truetype.h	/^   unsigned char x;$/;"	m	struct:__anon21
x	untitled.h	/^	float x,y,z;$/;"	m	struct:vertex_struct
x0	stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon4
x0	stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
x0	stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon7
x0	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon6
x0	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon8
x1	stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon4
x1	stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
x1	stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon7
x1	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon6
x1	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon8
xadvance	stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon6
xadvance	stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon8
xoff	stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon6
xoff	stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon8
xoff2	stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon8
y	imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4
y	imgui.h	/^    float x, y;$/;"	m	struct:ImVec2
y	palace.h	/^	float x,y,z;$/;"	m	struct:vertex_struct
y	stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon24
y	stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect
y	stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node
y	stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon5
y	stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon11
y	stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon19
y	stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon20
y	stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect
y	untitled.h	/^	float x,y,z;$/;"	m	struct:vertex_struct
y0	stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
y0	stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon7
y0	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon6
y0	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon8
y1	stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
y1	stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon7
y1	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon6
y1	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon8
ymax	stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon4
ymin	stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon4
yoff	stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon6
yoff	stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon8
yoff2	stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon8
z	imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4
z	palace.h	/^	float x,y,z;$/;"	m	struct:vertex_struct
z	untitled.h	/^	float x,y,z;$/;"	m	struct:vertex_struct
~AppStateAndEvents	app_state_and_events.cpp	/^AppStateAndEvents::~AppStateAndEvents() {$/;"	f	class:AppStateAndEvents
~ExampleAppConsole	imgui_demo.cpp	/^    ~ExampleAppConsole()$/;"	f	struct:ExampleAppConsole
~ImDrawList	imgui.h	/^    ~ImDrawList() { ClearFreeMemory(); }$/;"	f	struct:ImDrawList
~ImFont	imgui_draw.cpp	/^ImFont::~ImFont()$/;"	f	class:ImFont
~ImFontAtlas	imgui_draw.cpp	/^ImFontAtlas::~ImFontAtlas()$/;"	f	class:ImFontAtlas
~ImGuiListClipper	imgui.h	/^    ~ImGuiListClipper()                        { IM_ASSERT(ItemsCount == -1); } \/\/ user forgot to call End()$/;"	f	struct:ImGuiListClipper
~ImGuiTextFilter	imgui.h	/^    ~ImGuiTextFilter() {}$/;"	f	struct:ImGuiTextFilter
~ImGuiWindow	imgui.cpp	/^ImGuiWindow::~ImGuiWindow()$/;"	f	class:ImGuiWindow
~ImVector	imgui.h	/^    ~ImVector()                 { if (Data) ImGui::MemFree(Data); }$/;"	f	class:ImVector
